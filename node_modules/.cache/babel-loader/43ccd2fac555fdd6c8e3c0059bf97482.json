{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Slab = exports.SLAB_LAYOUT = void 0;\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar buffer_layout_1 = require(\"buffer-layout\");\n\nvar layout_1 = require(\"./layout\");\n\nvar SLAB_HEADER_LAYOUT = buffer_layout_1.struct([// Number of modified slab nodes\nbuffer_layout_1.u32('bumpIndex'), layout_1.zeros(4), // Linked list of unused nodes\nbuffer_layout_1.u32('freeListLen'), layout_1.zeros(4), buffer_layout_1.u32('freeListHead'), buffer_layout_1.u32('root'), buffer_layout_1.u32('leafCount'), layout_1.zeros(4)], 'header');\nvar SLAB_NODE_LAYOUT = buffer_layout_1.union(buffer_layout_1.u32('tag'), buffer_layout_1.blob(68), 'node');\nSLAB_NODE_LAYOUT.addVariant(0, buffer_layout_1.struct([]), 'uninitialized');\nSLAB_NODE_LAYOUT.addVariant(1, buffer_layout_1.struct([// Only the first prefixLen high-order bits of key are meaningful\nbuffer_layout_1.u32('prefixLen'), layout_1.u128('key'), buffer_layout_1.seq(buffer_layout_1.u32(), 2, 'children')]), 'innerNode');\nSLAB_NODE_LAYOUT.addVariant(2, buffer_layout_1.struct([buffer_layout_1.u8('ownerSlot'), buffer_layout_1.u8('feeTier'), buffer_layout_1.blob(2), layout_1.u128('key'), layout_1.publicKeyLayout('owner'), layout_1.u64('quantity'), layout_1.u64('clientOrderId')]), 'leafNode');\nSLAB_NODE_LAYOUT.addVariant(3, buffer_layout_1.struct([buffer_layout_1.u32('next')]), 'freeNode');\nSLAB_NODE_LAYOUT.addVariant(4, buffer_layout_1.struct([]), 'lastFreeNode');\nexports.SLAB_LAYOUT = buffer_layout_1.struct([SLAB_HEADER_LAYOUT, buffer_layout_1.seq(SLAB_NODE_LAYOUT, buffer_layout_1.offset(SLAB_HEADER_LAYOUT.layoutFor('bumpIndex'), SLAB_HEADER_LAYOUT.offsetOf('bumpIndex') - SLAB_HEADER_LAYOUT.span), 'nodes')]);\n\nvar Slab = /*#__PURE__*/function () {\n  function Slab(header, nodes) {\n    _classCallCheck(this, Slab);\n\n    this.header = header;\n    this.nodes = nodes;\n  }\n\n  _createClass(Slab, [{\n    key: \"get\",\n    value: function get(searchKey) {\n      if (this.header.leafCount === 0) {\n        return null;\n      }\n\n      if (!(searchKey instanceof bn_js_1.default)) {\n        searchKey = new bn_js_1.default(searchKey);\n      }\n\n      var index = this.header.root;\n\n      while (true) {\n        var _this$nodes$index = this.nodes[index],\n            leafNode = _this$nodes$index.leafNode,\n            innerNode = _this$nodes$index.innerNode;\n\n        if (leafNode) {\n          if (leafNode.key.eq(searchKey)) {\n            return leafNode;\n          }\n\n          return null;\n        } else if (innerNode) {\n          if (!innerNode.key.xor(searchKey).iushrn(128 - innerNode.prefixLen).isZero()) {\n            return null;\n          }\n\n          index = innerNode.children[searchKey.testn(128 - innerNode.prefixLen - 1) ? 1 : 0];\n        } else {\n          throw new Error('Invalid slab');\n        }\n      }\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this.items(false);\n    }\n  }, {\n    key: \"items\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function items() {\n      var descending,\n          stack,\n          index,\n          _this$nodes$index2,\n          leafNode,\n          innerNode,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function items$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              descending = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;\n\n              if (!(this.header.leafCount === 0)) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 3:\n              stack = [this.header.root];\n\n            case 4:\n              if (!(stack.length > 0)) {\n                _context.next = 15;\n                break;\n              }\n\n              index = stack.pop();\n              _this$nodes$index2 = this.nodes[index], leafNode = _this$nodes$index2.leafNode, innerNode = _this$nodes$index2.innerNode;\n\n              if (!leafNode) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 10;\n              return leafNode;\n\n            case 10:\n              _context.next = 13;\n              break;\n\n            case 12:\n              if (innerNode) {\n                if (descending) {\n                  stack.push(innerNode.children[0], innerNode.children[1]);\n                } else {\n                  stack.push(innerNode.children[1], innerNode.children[0]);\n                }\n              }\n\n            case 13:\n              _context.next = 4;\n              break;\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, items, this);\n    })\n  }], [{\n    key: \"decode\",\n    value: function decode(buffer) {\n      return exports.SLAB_LAYOUT.decode(buffer);\n    }\n  }]);\n\n  return Slab;\n}();\n\nexports.Slab = Slab;\nlayout_1.setLayoutDecoder(exports.SLAB_LAYOUT, function (_ref) {\n  var header = _ref.header,\n      nodes = _ref.nodes;\n  return new Slab(header, nodes);\n});","map":null,"metadata":{},"sourceType":"script"}