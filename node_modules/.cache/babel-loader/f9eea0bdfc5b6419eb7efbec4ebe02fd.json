{"ast":null,"code":"import _regeneratorRuntime from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nvar configurationValue = 1;\nvar endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nvar TransportWebUSB = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportWebUSB, _Transport);\n\n  var _super = _createSuper(TransportWebUSB);\n\n  function TransportWebUSB(device, interfaceNumber) {\n    var _this;\n\n    _classCallCheck(this, TransportWebUSB);\n\n    _this = _super.call(this);\n    _this.device = void 0;\n    _this.deviceModel = void 0;\n    _this.channel = Math.floor(Math.random() * 0xffff);\n    _this.packetSize = 64;\n    _this.interfaceNumber = void 0;\n    _this._disconnectEmitted = false;\n\n    _this._emitDisconnect = function (e) {\n      if (_this._disconnectEmitted) return;\n      _this._disconnectEmitted = true;\n\n      _this.emit(\"disconnect\", e);\n    };\n\n    _this.exchange = function (apdu) {\n      return _this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _assertThisInitialize, channel, packetSize, framing, blocks, i, result, acc, r, buffer;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _assertThisInitialize = _assertThisInitialized(_this), channel = _assertThisInitialize.channel, packetSize = _assertThisInitialize.packetSize;\n                log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                framing = hidFraming(channel, packetSize); // Write...\n\n                blocks = framing.makeBlocks(apdu);\n                i = 0;\n\n              case 5:\n                if (!(i < blocks.length)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 8;\n                return _this.device.transferOut(endpointNumber, blocks[i]);\n\n              case 8:\n                i++;\n                _context.next = 5;\n                break;\n\n              case 11:\n                if (result = framing.getReducedResult(acc)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                _context.next = 14;\n                return _this.device.transferIn(endpointNumber, packetSize);\n\n              case 14:\n                r = _context.sent;\n                buffer = Buffer.from(r.data.buffer);\n                acc = framing.reduceResponse(acc, buffer);\n                _context.next = 11;\n                break;\n\n              case 19:\n                log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                return _context.abrupt(\"return\", result);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (e) {\n        if (e && e.message && e.message.includes(\"disconnected\")) {\n          _this._emitDisconnect(e);\n\n          throw new DisconnectedDeviceDuringOperation(e.message);\n        }\n\n        throw e;\n      });\n    };\n\n    _this.device = device;\n    _this.interfaceNumber = interfaceNumber;\n    _this.deviceModel = identifyUSBProductId(device.productId);\n    return _this;\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  _createClass(TransportWebUSB, [{\n    key: \"close\",\n\n    /**\n     * Release the transport device\n     */\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.exchangeBusyPromise;\n\n              case 2:\n                _context2.next = 4;\n                return this.device.releaseInterface(this.interfaceNumber);\n\n              case 4:\n                _context2.next = 6;\n                return gracefullyResetDevice(this.device);\n\n              case 6:\n                _context2.next = 8;\n                return this.device.close();\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey() {}\n  }], [{\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var device;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return requestLedgerDevice();\n\n              case 2:\n                device = _context3.sent;\n                return _context3.abrupt(\"return\", TransportWebUSB.open(device));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function request() {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n\n  }, {\n    key: \"openConnected\",\n    value: function () {\n      var _openConnected = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var devices;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return getLedgerDevices();\n\n              case 2:\n                devices = _context4.sent;\n\n                if (!(devices.length === 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", null);\n\n              case 5:\n                return _context4.abrupt(\"return\", TransportWebUSB.open(devices[0]));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function openConnected() {\n        return _openConnected.apply(this, arguments);\n      }\n\n      return openConnected;\n    }()\n    /**\n     * Create a Ledger transport with a USBDevice\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(device) {\n        var iface, interfaceNumber, transport, onDisconnect;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return device.open();\n\n              case 2:\n                if (!(device.configuration === null)) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                _context5.next = 5;\n                return device.selectConfiguration(configurationValue);\n\n              case 5:\n                _context5.next = 7;\n                return gracefullyResetDevice(device);\n\n              case 7:\n                iface = device.configurations[0].interfaces.find(function (_ref2) {\n                  var alternates = _ref2.alternates;\n                  return alternates.some(function (a) {\n                    return a.interfaceClass === 255;\n                  });\n                });\n\n                if (iface) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n\n              case 10:\n                interfaceNumber = iface.interfaceNumber;\n                _context5.prev = 11;\n                _context5.next = 14;\n                return device.claimInterface(interfaceNumber);\n\n              case 14:\n                _context5.next = 21;\n                break;\n\n              case 16:\n                _context5.prev = 16;\n                _context5.t0 = _context5[\"catch\"](11);\n                _context5.next = 20;\n                return device.close();\n\n              case 20:\n                throw new TransportInterfaceNotAvailable(_context5.t0.message);\n\n              case 21:\n                transport = new TransportWebUSB(device, interfaceNumber);\n\n                onDisconnect = function onDisconnect(e) {\n                  if (device === e.device) {\n                    // $FlowFixMe\n                    navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n                    transport._emitDisconnect(new DisconnectedDevice());\n                  }\n                }; // $FlowFixMe\n\n\n                navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n                return _context5.abrupt(\"return\", transport);\n\n              case 25:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[11, 16]]);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }]);\n\n  return TransportWebUSB;\n}(Transport);\n\nexport { TransportWebUSB as default };\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\n\nTransportWebUSB.listen = function (observer) {\n  var unsubscribed = false;\n  getFirstLedgerDevice().then(function (device) {\n    if (!unsubscribed) {\n      var deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel: deviceModel\n      });\n      observer.complete();\n    }\n  }, function (error) {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe: unsubscribe\n  };\n};\n\nfunction gracefullyResetDevice(_x2) {\n  return _gracefullyResetDevice.apply(this, arguments);\n}\n\nfunction _gracefullyResetDevice() {\n  _gracefullyResetDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(device) {\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _context6.next = 3;\n            return device.reset();\n\n          case 3:\n            _context6.next = 8;\n            break;\n\n          case 5:\n            _context6.prev = 5;\n            _context6.t0 = _context6[\"catch\"](0);\n            console.warn(_context6.t0);\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[0, 5]]);\n  }));\n  return _gracefullyResetDevice.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}