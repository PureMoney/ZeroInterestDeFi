{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n/**\n */\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\n\nvar Transport = /*#__PURE__*/function () {\n  function Transport() {\n    var _this = this;\n\n    _classCallCheck(this, Transport);\n\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n\n    this.send = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cla, ins, p1, p2) {\n        var data,\n            statusList,\n            response,\n            sw,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _args.length > 4 && _args[4] !== undefined ? _args[4] : Buffer.alloc(0);\n                statusList = _args.length > 5 && _args[5] !== undefined ? _args[5] : [StatusCodes.OK];\n\n                if (!(data.length >= 256)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n\n              case 4:\n                _context.next = 6;\n                return _this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));\n\n              case 6:\n                response = _context.sent;\n                sw = response.readUInt16BE(response.length - 2);\n\n                if (statusList.some(function (s) {\n                  return s === sw;\n                })) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new TransportStatusError(sw);\n\n              case 10:\n                return _context.abrupt(\"return\", response);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.exchangeBusyPromise = void 0;\n\n    this.exchangeAtomicImpl = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(f) {\n        var resolveBusy, busyPromise, unresponsiveReached, timeout, res;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!_this.exchangeBusyPromise) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n\n              case 2:\n                busyPromise = new Promise(function (r) {\n                  resolveBusy = r;\n                });\n                _this.exchangeBusyPromise = busyPromise;\n                unresponsiveReached = false;\n                timeout = setTimeout(function () {\n                  unresponsiveReached = true;\n\n                  _this.emit(\"unresponsive\");\n                }, _this.unresponsiveTimeout);\n                _context2.prev = 6;\n                _context2.next = 9;\n                return f();\n\n              case 9:\n                res = _context2.sent;\n\n                if (unresponsiveReached) {\n                  _this.emit(\"responsive\");\n                }\n\n                return _context2.abrupt(\"return\", res);\n\n              case 12:\n                _context2.prev = 12;\n                clearTimeout(timeout);\n                if (resolveBusy) resolveBusy();\n                _this.exchangeBusyPromise = null;\n                return _context2.finish(12);\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[6,, 12, 17]]);\n      }));\n\n      return function (_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this._appAPIlock = null;\n  }\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n\n\n  _createClass(Transport, [{\n    key: \"exchange\",\n    value: function exchange(_apdu) {\n      throw new Error(\"exchange not implemented\");\n    }\n    /**\n     * set the \"scramble key\" for the next exchanges with the device.\n     * Each App can have a different scramble key and they internally will set it at instanciation.\n     * @param key the scramble key\n     */\n\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey(_key) {}\n    /**\n     * close the exchange with the device.\n     * @return a Promise that ends when the transport is closed.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.resolve();\n    }\n    /**\n     * Listen to an event on an instance of transport.\n     * Transport implementation can have specific events. Here is the common events:\n     * * `\"disconnect\"` : triggered if Transport is disconnected\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, cb) {\n      this._events.on(eventName, cb);\n    }\n    /**\n     * Stop listening to an event on an instance of transport.\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, cb) {\n      this._events.removeListener(eventName, cb);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var _this$_events;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      (_this$_events = this._events).emit.apply(_this$_events, [event].concat(args));\n    }\n    /**\n     * Enable or not logs of the binary exchange\n     */\n\n  }, {\n    key: \"setDebugMode\",\n    value: function setDebugMode() {\n      console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n    }\n    /**\n     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n     */\n\n  }, {\n    key: \"setExchangeTimeout\",\n    value: function setExchangeTimeout(exchangeTimeout) {\n      this.exchangeTimeout = exchangeTimeout;\n    }\n    /**\n     * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n     */\n\n  }, {\n    key: \"setExchangeUnresponsiveTimeout\",\n    value: function setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n      this.unresponsiveTimeout = unresponsiveTimeout;\n    }\n    /**\n     * wrapper on top of exchange to simplify work of the implementation.\n     * @param cla\n     * @param ins\n     * @param p1\n     * @param p2\n     * @param data\n     * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n     * @return a Promise of response buffer\n     */\n\n    /**\n     * create() allows to open the first descriptor available or\n     * throw if there is none or if timeout is reached.\n     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n     * @example\n    TransportFoo.create().then(transport => ...)\n     */\n\n  }, {\n    key: \"decorateAppAPIMethods\",\n    value: function decorateAppAPIMethods(self, methods, scrambleKey) {\n      var _iterator = _createForOfIteratorHelper(methods),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var methodName = _step.value;\n          self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"decorateAppAPIMethod\",\n    value: function decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n      var _this2 = this;\n\n      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _appAPIlock,\n            _len2,\n            args,\n            _key3,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _appAPIlock = _this2._appAPIlock;\n\n                if (!_appAPIlock) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\")));\n\n              case 3:\n                _context3.prev = 3;\n                _this2._appAPIlock = methodName;\n\n                _this2.setScrambleKey(scrambleKey);\n\n                for (_len2 = _args3.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n                  args[_key3] = _args3[_key3];\n                }\n\n                _context3.next = 9;\n                return f.apply(ctx, args);\n\n              case 9:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 10:\n                _context3.prev = 10;\n                _this2._appAPIlock = null;\n                return _context3.finish(10);\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[3,, 10, 13]]);\n      }));\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var _this3 = this;\n\n      var openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;\n      var listenTimeout = arguments.length > 1 ? arguments[1] : undefined;\n      return new Promise(function (resolve, reject) {\n        var found = false;\n\n        var sub = _this3.listen({\n          next: function next(e) {\n            found = true;\n            if (sub) sub.unsubscribe();\n            if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n            _this3.open(e.descriptor, openTimeout).then(resolve, reject);\n          },\n          error: function error(e) {\n            if (listenTimeoutId) clearTimeout(listenTimeoutId);\n            reject(e);\n          },\n          complete: function complete() {\n            if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n            if (!found) {\n              reject(new TransportError(_this3.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n            }\n          }\n        });\n\n        var listenTimeoutId = listenTimeout ? setTimeout(function () {\n          sub.unsubscribe();\n          reject(new TransportError(_this3.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n        }, listenTimeout) : null;\n      });\n    }\n  }]);\n\n  return Transport;\n}();\n\nexport { Transport as default };\nTransport.isSupported = void 0;\nTransport.list = void 0;\nTransport.listen = void 0;\nTransport.open = void 0;\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";","map":null,"metadata":{},"sourceType":"module"}