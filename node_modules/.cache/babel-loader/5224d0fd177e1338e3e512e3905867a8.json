{"ast":null,"code":"import _objectWithoutProperties from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";import _slicedToArray from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _createForOfIteratorHelper from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _regeneratorRuntime from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _objectSpread from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import React,{useCallback,useContext,useEffect,useState}from\"react\";import{useConnection}from\"./connection\";import{useWallet}from\"./wallet\";import{PublicKey}from\"@solana/web3.js\";import{AccountLayout,u64,MintLayout}from\"@solana/spl-token\";import{chunks}from\"./../utils/utils\";import{EventEmitter}from\"./../utils/eventEmitter\";import{useUserAccounts}from\"../hooks/useUserAccounts\";import{WRAPPED_SOL_MINT,programIds}from\"../utils/ids\";var AccountsContext=React.createContext(null);var pendingCalls=new Map();var genericCache=new Map();var transactionCache=new Map();export var MintParser=function MintParser(pubKey,info){var buffer=Buffer.from(info.data);var data=deserializeMint(buffer);var details={pubkey:pubKey,account:_objectSpread({},info),info:data};return details;};export var TokenAccountParser=function TokenAccountParser(pubKey,info){var buffer=Buffer.from(info.data);var data=deserializeAccount(buffer);var details={pubkey:pubKey,account:_objectSpread({},info),info:data};return details;};export var GenericAccountParser=function GenericAccountParser(pubKey,info){var buffer=Buffer.from(info.data);var details={pubkey:pubKey,account:_objectSpread({},info),info:buffer};return details;};export var keyToAccountParser=new Map();export var cache={emitter:new EventEmitter(),query:function(){var _query=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection,pubKey,parser){var id,address,account,query;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(typeof pubKey===\"string\"){id=new PublicKey(pubKey);}else{id=pubKey;}address=id.toBase58();account=genericCache.get(address);if(!account){_context.next=5;break;}return _context.abrupt(\"return\",account);case 5:query=pendingCalls.get(address);if(!query){_context.next=8;break;}return _context.abrupt(\"return\",query);case 8:// TODO: refactor to use multiple accounts query with flush like behavior\nquery=connection.getAccountInfo(id).then(function(data){if(!data){throw new Error(\"Account not found\");}return cache.add(id,data,parser);});pendingCalls.set(address,query);return _context.abrupt(\"return\",query);case 11:case\"end\":return _context.stop();}}},_callee);}));function query(_x,_x2,_x3){return _query.apply(this,arguments);}return query;}(),add:function add(id,obj,parser){if(obj.data.length===0){return;}var address=typeof id===\"string\"?id:id===null||id===void 0?void 0:id.toBase58();var deserialize=parser?parser:keyToAccountParser.get(address);if(!deserialize){throw new Error(\"Deserializer needs to be registered or passed as a parameter\");}cache.registerParser(id,deserialize);pendingCalls.delete(address);var account=deserialize(new PublicKey(address),obj);if(!account){return;}var isNew=!genericCache.has(address);genericCache.set(address,account);cache.emitter.raiseCacheUpdated(address,isNew,deserialize);return account;},get:function get(pubKey){var key;if(typeof pubKey!==\"string\"){key=pubKey.toBase58();}else{key=pubKey;}return genericCache.get(key);},delete:function _delete(pubKey){var key;if(typeof pubKey!==\"string\"){key=pubKey.toBase58();}else{key=pubKey;}if(genericCache.get(key)){genericCache.delete(key);cache.emitter.raiseCacheDeleted(key);return true;}return false;},byParser:function byParser(parser){var result=[];var _iterator=_createForOfIteratorHelper(keyToAccountParser.keys()),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var id=_step.value;if(keyToAccountParser.get(id)===parser){result.push(id);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return result;},registerParser:function registerParser(pubkey,parser){if(pubkey){var address=typeof pubkey===\"string\"?pubkey:pubkey===null||pubkey===void 0?void 0:pubkey.toBase58();keyToAccountParser.set(address,parser);}return pubkey;},addTransaction:function addTransaction(signature,tx){transactionCache.set(signature,tx);return tx;},addBulkTransactions:function addBulkTransactions(txs){var _iterator2=_createForOfIteratorHelper(txs),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var tx=_step2.value;transactionCache.set(tx.signature.signature,tx);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return txs;},getTransaction:function getTransaction(signature){var transaction=transactionCache.get(signature);return transaction;},getAllTransactions:function getAllTransactions(){return transactionCache;},clear:function clear(){genericCache.clear();transactionCache.clear();cache.emitter.raiseCacheCleared();}};export var useAccountsContext=function useAccountsContext(){var context=useContext(AccountsContext);return context;};function wrapNativeAccount(pubkey,account){if(!account){return undefined;}return{pubkey:pubkey,account:account,info:{address:pubkey,mint:WRAPPED_SOL_MINT,owner:pubkey,amount:new u64(account.lamports),delegate:null,delegatedAmount:new u64(0),isInitialized:true,isFrozen:false,isNative:true,rentExemptReserve:null,closeAuthority:null}};}var UseNativeAccount=function UseNativeAccount(){var connection=useConnection();var _useWallet=useWallet(),wallet=_useWallet.wallet,publicKey=_useWallet.publicKey;var _useState=useState(),_useState2=_slicedToArray(_useState,2),nativeAccount=_useState2[0],setNativeAccount=_useState2[1];var updateCache=useCallback(function(account){if(!connection||!publicKey){return;}var wrapped=wrapNativeAccount(publicKey,account);if(wrapped!==undefined){var id=publicKey.toBase58();cache.registerParser(id,TokenAccountParser);genericCache.set(id,wrapped);cache.emitter.raiseCacheUpdated(id,false,TokenAccountParser);}},[publicKey,connection]);useEffect(function(){if(!connection||!publicKey){return;}connection.getAccountInfo(publicKey).then(function(acc){if(acc){updateCache(acc);setNativeAccount(acc);}});connection.onAccountChange(publicKey,function(acc){if(acc){updateCache(acc);setNativeAccount(acc);}});},[setNativeAccount,wallet,publicKey,connection,updateCache]);return{nativeAccount:nativeAccount};};var PRECACHED_OWNERS=new Set();var precacheUserTokenAccounts=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection,owner){var accounts;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(owner){_context2.next=2;break;}return _context2.abrupt(\"return\");case 2:// used for filtering account updates over websocket\nPRECACHED_OWNERS.add(owner.toBase58());// user accounts are update via ws subscription\n_context2.next=5;return connection.getTokenAccountsByOwner(owner,{programId:programIds().token});case 5:accounts=_context2.sent;accounts.value.forEach(function(info){cache.add(info.pubkey.toBase58(),info.account,TokenAccountParser);});case 7:case\"end\":return _context2.stop();}}},_callee2);}));return function precacheUserTokenAccounts(_x4,_x5){return _ref.apply(this,arguments);};}();export function AccountsProvider(_ref2){var _ref2$children=_ref2.children,children=_ref2$children===void 0?null:_ref2$children;var connection=useConnection();var _useWallet2=useWallet(),publicKey=_useWallet2.publicKey,wallet=_useWallet2.wallet,connected=_useWallet2.connected;var _useState3=useState([]),_useState4=_slicedToArray(_useState3,2),tokenAccounts=_useState4[0],setTokenAccounts=_useState4[1];var _useState5=useState([]),_useState6=_slicedToArray(_useState5,2),userAccounts=_useState6[0],setUserAccounts=_useState6[1];var _UseNativeAccount=UseNativeAccount(),nativeAccount=_UseNativeAccount.nativeAccount;var selectUserAccounts=useCallback(function(){if(!publicKey){return[];}var address=publicKey.toBase58();return cache.byParser(TokenAccountParser).map(function(id){return cache.get(id);}).filter(function(a){return a&&a.info.owner.toBase58()===address;}).map(function(a){return a;});},[publicKey]);useEffect(function(){var accounts=selectUserAccounts().filter(function(a){return a!==undefined;});setUserAccounts(accounts);},[nativeAccount,wallet,tokenAccounts,selectUserAccounts]);useEffect(function(){var subs=[];cache.emitter.onCache(function(args){if(args.isNew){var id=args.id;var deserialize=args.parser;connection.onAccountChange(new PublicKey(id),function(info){cache.add(id,info,deserialize);});}});return function(){subs.forEach(function(id){return connection.removeAccountChangeListener(id);});};},[connection]);useEffect(function(){if(!connection||!publicKey){setTokenAccounts([]);}else{precacheUserTokenAccounts(connection,publicKey).then(function(){setTokenAccounts(selectUserAccounts());});// This can return different types of accounts: token-account, mint, multisig\n// TODO: web3.js expose ability to filter.\n// this should use only filter syntax to only get accounts that are owned by user\nvar tokenSubID=connection.onProgramAccountChange(programIds().token,function(info){// TODO: fix type in web3.js\nvar id=info.accountId;// TODO: do we need a better way to identify layout (maybe a enum identifing type?)\nif(info.accountInfo.data.length===AccountLayout.span){var _data=deserializeAccount(info.accountInfo.data);if(PRECACHED_OWNERS.has(_data.owner.toBase58())){cache.add(id,info.accountInfo,TokenAccountParser);setTokenAccounts(selectUserAccounts());}}},\"singleGossip\");return function(){connection.removeProgramAccountChangeListener(tokenSubID);};}},[connection,connected,publicKey,selectUserAccounts]);return/*#__PURE__*/React.createElement(AccountsContext.Provider,{value:{userAccounts:userAccounts,nativeAccount:nativeAccount}},children);}export function useNativeAccount(){var context=useContext(AccountsContext);return{account:context.nativeAccount};}export var getMultipleAccounts=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection,keys,commitment){var result,array;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return Promise.all(chunks(keys,99).map(function(chunk){return getMultipleAccountsCore(connection,chunk,commitment);}));case 2:result=_context3.sent;array=result.map(function(a){return a.array.map(function(acc){if(!acc){return undefined;}var data=acc.data,rest=_objectWithoutProperties(acc,[\"data\"]);var obj=_objectSpread(_objectSpread({},rest),{},{data:Buffer.from(data[0],\"base64\")});return obj;}).filter(function(_){return _;});}).flat();return _context3.abrupt(\"return\",{keys:keys,array:array});case 5:case\"end\":return _context3.stop();}}},_callee3);}));return function getMultipleAccounts(_x6,_x7,_x8){return _ref3.apply(this,arguments);};}();var getMultipleAccountsCore=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(connection,keys,commitment){var args,unsafeRes,array;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:args=connection._buildArgs([keys],commitment,\"base64\");_context4.next=3;return connection._rpcRequest(\"getMultipleAccounts\",args);case 3:unsafeRes=_context4.sent;if(!unsafeRes.error){_context4.next=6;break;}throw new Error(\"failed to get info about account \"+unsafeRes.error.message);case 6:if(!unsafeRes.result.value){_context4.next=9;break;}array=unsafeRes.result.value;return _context4.abrupt(\"return\",{keys:keys,array:array});case 9:throw new Error();case 10:case\"end\":return _context4.stop();}}},_callee4);}));return function getMultipleAccountsCore(_x9,_x10,_x11){return _ref4.apply(this,arguments);};}();export function useMint(key){var connection=useConnection();var _useState7=useState(),_useState8=_slicedToArray(_useState7,2),mint=_useState8[0],setMint=_useState8[1];var id=typeof key===\"string\"?key:key===null||key===void 0?void 0:key.toBase58();useEffect(function(){if(!id){return;}cache.query(connection,id,MintParser).then(function(acc){return setMint(acc.info);}).catch(function(err){return console.log(err);});var dispose=cache.emitter.onCache(function(e){var event=e;if(event.id===id){cache.query(connection,id,MintParser).then(function(mint){return setMint(mint.info);});}});return function(){dispose();};},[connection,id]);return mint;}export var useAccountByMint=function useAccountByMint(mint){var _useUserAccounts=useUserAccounts(),userAccounts=_useUserAccounts.userAccounts;var index=userAccounts.findIndex(function(acc){return acc.info.mint.toBase58()===mint;});if(index!==-1){return userAccounts[index];}return;};export function useAccount(pubKey){var connection=useConnection();var _useState9=useState(),_useState10=_slicedToArray(_useState9,2),account=_useState10[0],setAccount=_useState10[1];var key=pubKey===null||pubKey===void 0?void 0:pubKey.toBase58();useEffect(function(){var query=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(){var acc;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.prev=0;if(key){_context5.next=3;break;}return _context5.abrupt(\"return\");case 3:_context5.next=5;return cache.query(connection,key,TokenAccountParser).catch(function(err){return console.log(err);});case 5:acc=_context5.sent;if(acc){setAccount(acc);}_context5.next=12;break;case 9:_context5.prev=9;_context5.t0=_context5[\"catch\"](0);console.error(_context5.t0);case 12:case\"end\":return _context5.stop();}}},_callee5,null,[[0,9]]);}));return function query(){return _ref5.apply(this,arguments);};}();query();var dispose=cache.emitter.onCache(function(e){var event=e;if(event.id===key){query();}});return function(){dispose();};},[connection,key]);return account;}// TODO: expose in spl package\nvar deserializeAccount=function deserializeAccount(data){var accountInfo=AccountLayout.decode(data);accountInfo.mint=new PublicKey(accountInfo.mint);accountInfo.owner=new PublicKey(accountInfo.owner);accountInfo.amount=u64.fromBuffer(accountInfo.amount);if(accountInfo.delegateOption===0){accountInfo.delegate=null;accountInfo.delegatedAmount=new u64(0);}else{accountInfo.delegate=new PublicKey(accountInfo.delegate);accountInfo.delegatedAmount=u64.fromBuffer(accountInfo.delegatedAmount);}accountInfo.isInitialized=accountInfo.state!==0;accountInfo.isFrozen=accountInfo.state===2;if(accountInfo.isNativeOption===1){accountInfo.rentExemptReserve=u64.fromBuffer(accountInfo.isNative);accountInfo.isNative=true;}else{accountInfo.rentExemptReserve=null;accountInfo.isNative=false;}if(accountInfo.closeAuthorityOption===0){accountInfo.closeAuthority=null;}else{accountInfo.closeAuthority=new PublicKey(accountInfo.closeAuthority);}return accountInfo;};// TODO: expose in spl package\nvar deserializeMint=function deserializeMint(data){if(data.length!==MintLayout.span){throw new Error(\"Not a valid Mint\");}var mintInfo=MintLayout.decode(data);if(mintInfo.mintAuthorityOption===0){mintInfo.mintAuthority=null;}else{mintInfo.mintAuthority=new PublicKey(mintInfo.mintAuthority);}mintInfo.supply=u64.fromBuffer(mintInfo.supply);mintInfo.isInitialized=mintInfo.isInitialized!==0;if(mintInfo.freezeAuthorityOption===0){mintInfo.freezeAuthority=null;}else{mintInfo.freezeAuthority=new PublicKey(mintInfo.freezeAuthority);}return mintInfo;};","map":null,"metadata":{},"sourceType":"module"}