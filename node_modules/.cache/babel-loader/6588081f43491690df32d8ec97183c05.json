{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMintDecimals = exports.Orderbook = exports.ORDERBOOK_LAYOUT = exports.OpenOrders = exports._OPEN_ORDERS_LAYOUT_V2 = exports._OPEN_ORDERS_LAYOUT_V1 = exports.Market = exports._MARKET_STATE_LAYOUT_V2 = exports._MARKET_STAT_LAYOUT_V1 = void 0;\n\nvar buffer_layout_1 = require(\"buffer-layout\");\n\nvar layout_1 = require(\"./layout\");\n\nvar slab_1 = require(\"./slab\");\n\nvar instructions_1 = require(\"./instructions\");\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nvar queue_1 = require(\"./queue\");\n\nvar buffer_1 = require(\"buffer\");\n\nvar fees_1 = require(\"./fees\");\n\nvar token_instructions_1 = require(\"./token-instructions\");\n\nvar tokens_and_markets_1 = require(\"./tokens_and_markets\");\n\nexports._MARKET_STAT_LAYOUT_V1 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('ownAddress'), layout_1.u64('vaultSignerNonce'), layout_1.publicKeyLayout('baseMint'), layout_1.publicKeyLayout('quoteMint'), layout_1.publicKeyLayout('baseVault'), layout_1.u64('baseDepositsTotal'), layout_1.u64('baseFeesAccrued'), layout_1.publicKeyLayout('quoteVault'), layout_1.u64('quoteDepositsTotal'), layout_1.u64('quoteFeesAccrued'), layout_1.u64('quoteDustThreshold'), layout_1.publicKeyLayout('requestQueue'), layout_1.publicKeyLayout('eventQueue'), layout_1.publicKeyLayout('bids'), layout_1.publicKeyLayout('asks'), layout_1.u64('baseLotSize'), layout_1.u64('quoteLotSize'), layout_1.u64('feeRateBps'), buffer_layout_1.blob(7)]);\nexports._MARKET_STATE_LAYOUT_V2 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('ownAddress'), layout_1.u64('vaultSignerNonce'), layout_1.publicKeyLayout('baseMint'), layout_1.publicKeyLayout('quoteMint'), layout_1.publicKeyLayout('baseVault'), layout_1.u64('baseDepositsTotal'), layout_1.u64('baseFeesAccrued'), layout_1.publicKeyLayout('quoteVault'), layout_1.u64('quoteDepositsTotal'), layout_1.u64('quoteFeesAccrued'), layout_1.u64('quoteDustThreshold'), layout_1.publicKeyLayout('requestQueue'), layout_1.publicKeyLayout('eventQueue'), layout_1.publicKeyLayout('bids'), layout_1.publicKeyLayout('asks'), layout_1.u64('baseLotSize'), layout_1.u64('quoteLotSize'), layout_1.u64('feeRateBps'), layout_1.u64('referrerRebatesAccrued'), buffer_layout_1.blob(7)]);\n\nvar Market = /*#__PURE__*/function () {\n  function Market(decoded, baseMintDecimals, quoteMintDecimals) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var programId = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, Market);\n\n    var _options$skipPrefligh = options.skipPreflight,\n        skipPreflight = _options$skipPrefligh === void 0 ? false : _options$skipPrefligh,\n        _options$commitment = options.commitment,\n        commitment = _options$commitment === void 0 ? 'recent' : _options$commitment;\n\n    if (!decoded.accountFlags.initialized || !decoded.accountFlags.market) {\n      throw new Error('Invalid market state');\n    }\n\n    this._decoded = decoded;\n    this._baseSplTokenDecimals = baseMintDecimals;\n    this._quoteSplTokenDecimals = quoteMintDecimals;\n    this._skipPreflight = skipPreflight;\n    this._commitment = commitment;\n    this._programId = programId;\n    this._openOrdersAccountsCache = {};\n    this._feeDiscountKeysCache = {};\n  }\n\n  _createClass(Market, [{\n    key: \"loadBids\",\n    value: function () {\n      var _loadBids = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection) {\n        var _throwIfNull, data;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.t0 = throwIfNull;\n                _context.next = 3;\n                return connection.getAccountInfo(this._decoded.bids);\n\n              case 3:\n                _context.t1 = _context.sent;\n                _throwIfNull = (0, _context.t0)(_context.t1);\n                data = _throwIfNull.data;\n                return _context.abrupt(\"return\", Orderbook.decode(this, data));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function loadBids(_x) {\n        return _loadBids.apply(this, arguments);\n      }\n\n      return loadBids;\n    }()\n  }, {\n    key: \"loadAsks\",\n    value: function () {\n      var _loadAsks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection) {\n        var _throwIfNull2, data;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = throwIfNull;\n                _context2.next = 3;\n                return connection.getAccountInfo(this._decoded.asks);\n\n              case 3:\n                _context2.t1 = _context2.sent;\n                _throwIfNull2 = (0, _context2.t0)(_context2.t1);\n                data = _throwIfNull2.data;\n                return _context2.abrupt(\"return\", Orderbook.decode(this, data));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function loadAsks(_x2) {\n        return _loadAsks.apply(this, arguments);\n      }\n\n      return loadAsks;\n    }()\n  }, {\n    key: \"loadOrdersForOwner\",\n    value: function () {\n      var _loadOrdersForOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection, ownerAddress) {\n        var cacheDurationMs,\n            _yield$Promise$all,\n            _yield$Promise$all2,\n            bids,\n            asks,\n            openOrdersAccounts,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                cacheDurationMs = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 0;\n                _context3.next = 3;\n                return Promise.all([this.loadBids(connection), this.loadAsks(connection), this.findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs)]);\n\n              case 3:\n                _yield$Promise$all = _context3.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n                bids = _yield$Promise$all2[0];\n                asks = _yield$Promise$all2[1];\n                openOrdersAccounts = _yield$Promise$all2[2];\n                return _context3.abrupt(\"return\", this.filterForOpenOrders(bids, asks, openOrdersAccounts));\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function loadOrdersForOwner(_x3, _x4) {\n        return _loadOrdersForOwner.apply(this, arguments);\n      }\n\n      return loadOrdersForOwner;\n    }()\n  }, {\n    key: \"filterForOpenOrders\",\n    value: function filterForOpenOrders(bids, asks, openOrdersAccounts) {\n      return [].concat(_toConsumableArray(bids), _toConsumableArray(asks)).filter(function (order) {\n        return openOrdersAccounts.some(function (openOrders) {\n          return order.openOrdersAddress.equals(openOrders.address);\n        });\n      });\n    }\n  }, {\n    key: \"findBaseTokenAccountsForOwner\",\n    value: function () {\n      var _findBaseTokenAccountsForOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(connection, ownerAddress) {\n        var includeUnwrappedSol,\n            _yield$Promise$all3,\n            _yield$Promise$all4,\n            wrapped,\n            unwrapped,\n            _args4 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                includeUnwrappedSol = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : false;\n\n                if (!(this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && includeUnwrappedSol)) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                _context4.next = 4;\n                return Promise.all([this.findBaseTokenAccountsForOwner(connection, ownerAddress, false), connection.getAccountInfo(ownerAddress)]);\n\n              case 4:\n                _yield$Promise$all3 = _context4.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n                wrapped = _yield$Promise$all4[0];\n                unwrapped = _yield$Promise$all4[1];\n\n                if (!(unwrapped !== null)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", [{\n                  pubkey: ownerAddress,\n                  account: unwrapped\n                }].concat(_toConsumableArray(wrapped)));\n\n              case 10:\n                return _context4.abrupt(\"return\", wrapped);\n\n              case 11:\n                _context4.next = 13;\n                return this.getTokenAccountsByOwnerForMint(connection, ownerAddress, this.baseMintAddress);\n\n              case 13:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function findBaseTokenAccountsForOwner(_x5, _x6) {\n        return _findBaseTokenAccountsForOwner.apply(this, arguments);\n      }\n\n      return findBaseTokenAccountsForOwner;\n    }()\n  }, {\n    key: \"getTokenAccountsByOwnerForMint\",\n    value: function () {\n      var _getTokenAccountsByOwnerForMint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connection, ownerAddress, mintAddress) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return connection.getTokenAccountsByOwner(ownerAddress, {\n                  mint: mintAddress\n                });\n\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent.value);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function getTokenAccountsByOwnerForMint(_x7, _x8, _x9) {\n        return _getTokenAccountsByOwnerForMint.apply(this, arguments);\n      }\n\n      return getTokenAccountsByOwnerForMint;\n    }()\n  }, {\n    key: \"findQuoteTokenAccountsForOwner\",\n    value: function () {\n      var _findQuoteTokenAccountsForOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(connection, ownerAddress) {\n        var includeUnwrappedSol,\n            _yield$Promise$all5,\n            _yield$Promise$all6,\n            wrapped,\n            unwrapped,\n            _args6 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                includeUnwrappedSol = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : false;\n\n                if (!(this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && includeUnwrappedSol)) {\n                  _context6.next = 11;\n                  break;\n                }\n\n                _context6.next = 4;\n                return Promise.all([this.findQuoteTokenAccountsForOwner(connection, ownerAddress, false), connection.getAccountInfo(ownerAddress)]);\n\n              case 4:\n                _yield$Promise$all5 = _context6.sent;\n                _yield$Promise$all6 = _slicedToArray(_yield$Promise$all5, 2);\n                wrapped = _yield$Promise$all6[0];\n                unwrapped = _yield$Promise$all6[1];\n\n                if (!(unwrapped !== null)) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", [{\n                  pubkey: ownerAddress,\n                  account: unwrapped\n                }].concat(_toConsumableArray(wrapped)));\n\n              case 10:\n                return _context6.abrupt(\"return\", wrapped);\n\n              case 11:\n                _context6.next = 13;\n                return this.getTokenAccountsByOwnerForMint(connection, ownerAddress, this.quoteMintAddress);\n\n              case 13:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function findQuoteTokenAccountsForOwner(_x10, _x11) {\n        return _findQuoteTokenAccountsForOwner.apply(this, arguments);\n      }\n\n      return findQuoteTokenAccountsForOwner;\n    }()\n  }, {\n    key: \"findOpenOrdersAccountsForOwner\",\n    value: function () {\n      var _findOpenOrdersAccountsForOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(connection, ownerAddress) {\n        var cacheDurationMs,\n            strOwner,\n            now,\n            openOrdersAccountsForOwner,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                cacheDurationMs = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 0;\n                strOwner = ownerAddress.toBase58();\n                now = new Date().getTime();\n\n                if (!(strOwner in this._openOrdersAccountsCache && now - this._openOrdersAccountsCache[strOwner].ts < cacheDurationMs)) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", this._openOrdersAccountsCache[strOwner].accounts);\n\n              case 5:\n                _context7.next = 7;\n                return OpenOrders.findForMarketAndOwner(connection, this.address, ownerAddress, this._programId);\n\n              case 7:\n                openOrdersAccountsForOwner = _context7.sent;\n                this._openOrdersAccountsCache[strOwner] = {\n                  accounts: openOrdersAccountsForOwner,\n                  ts: now\n                };\n                return _context7.abrupt(\"return\", openOrdersAccountsForOwner);\n\n              case 10:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function findOpenOrdersAccountsForOwner(_x12, _x13) {\n        return _findOpenOrdersAccountsForOwner.apply(this, arguments);\n      }\n\n      return findOpenOrdersAccountsForOwner;\n    }()\n  }, {\n    key: \"placeOrder\",\n    value: function () {\n      var _placeOrder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(connection, _ref) {\n        var owner, payer, side, price, size, _ref$orderType, orderType, clientId, openOrdersAddressKey, openOrdersAccount, feeDiscountPubkey, _yield$this$makePlace, transaction, signers;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                owner = _ref.owner, payer = _ref.payer, side = _ref.side, price = _ref.price, size = _ref.size, _ref$orderType = _ref.orderType, orderType = _ref$orderType === void 0 ? 'limit' : _ref$orderType, clientId = _ref.clientId, openOrdersAddressKey = _ref.openOrdersAddressKey, openOrdersAccount = _ref.openOrdersAccount, feeDiscountPubkey = _ref.feeDiscountPubkey;\n                _context8.next = 3;\n                return this.makePlaceOrderTransaction(connection, {\n                  owner: owner,\n                  payer: payer,\n                  side: side,\n                  price: price,\n                  size: size,\n                  orderType: orderType,\n                  clientId: clientId,\n                  openOrdersAddressKey: openOrdersAddressKey,\n                  openOrdersAccount: openOrdersAccount,\n                  feeDiscountPubkey: feeDiscountPubkey\n                });\n\n              case 3:\n                _yield$this$makePlace = _context8.sent;\n                transaction = _yield$this$makePlace.transaction;\n                signers = _yield$this$makePlace.signers;\n                _context8.next = 8;\n                return this._sendTransaction(connection, transaction, [owner].concat(_toConsumableArray(signers)));\n\n              case 8:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 9:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function placeOrder(_x14, _x15) {\n        return _placeOrder.apply(this, arguments);\n      }\n\n      return placeOrder;\n    }()\n  }, {\n    key: \"getSplTokenBalanceFromAccountInfo\",\n    value: function getSplTokenBalanceFromAccountInfo(accountInfo, decimals) {\n      return divideBnToNumber(new bn_js_1.default(accountInfo.data.slice(64, 72), 10, 'le'), new bn_js_1.default(10).pow(new bn_js_1.default(decimals)));\n    }\n  }, {\n    key: \"findFeeDiscountKeys\",\n    value: function () {\n      var _findFeeDiscountKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(connection, ownerAddress) {\n        var _this = this;\n\n        var cacheDurationMs,\n            sortedAccounts,\n            now,\n            strOwner,\n            msrmAccounts,\n            srmAccounts,\n            _args9 = arguments;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                cacheDurationMs = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : 0;\n                sortedAccounts = [];\n                now = new Date().getTime();\n                strOwner = ownerAddress.toBase58();\n\n                if (!(strOwner in this._feeDiscountKeysCache && now - this._feeDiscountKeysCache[strOwner].ts < cacheDurationMs)) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this._feeDiscountKeysCache[strOwner].accounts);\n\n              case 6:\n                if (!this.supportsSrmFeeDiscounts) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                _context9.next = 9;\n                return this.getTokenAccountsByOwnerForMint(connection, ownerAddress, token_instructions_1.MSRM_MINT);\n\n              case 9:\n                msrmAccounts = _context9.sent.map(function (_ref2) {\n                  var pubkey = _ref2.pubkey,\n                      account = _ref2.account;\n\n                  var balance = _this.getSplTokenBalanceFromAccountInfo(account, token_instructions_1.MSRM_DECIMALS);\n\n                  return {\n                    pubkey: pubkey,\n                    mint: token_instructions_1.MSRM_MINT,\n                    balance: balance,\n                    feeTier: fees_1.getFeeTier(balance, 0)\n                  };\n                });\n                _context9.next = 12;\n                return this.getTokenAccountsByOwnerForMint(connection, ownerAddress, token_instructions_1.SRM_MINT);\n\n              case 12:\n                srmAccounts = _context9.sent.map(function (_ref3) {\n                  var pubkey = _ref3.pubkey,\n                      account = _ref3.account;\n\n                  var balance = _this.getSplTokenBalanceFromAccountInfo(account, token_instructions_1.SRM_DECIMALS);\n\n                  return {\n                    pubkey: pubkey,\n                    mint: token_instructions_1.SRM_MINT,\n                    balance: balance,\n                    feeTier: fees_1.getFeeTier(0, balance)\n                  };\n                });\n                sortedAccounts = msrmAccounts.concat(srmAccounts).sort(function (a, b) {\n                  if (a.feeTier > b.feeTier) {\n                    return -1;\n                  } else if (a.feeTier < b.feeTier) {\n                    return 1;\n                  } else {\n                    if (a.balance > b.balance) {\n                      return -1;\n                    } else if (a.balance < b.balance) {\n                      return 1;\n                    } else {\n                      return 0;\n                    }\n                  }\n                });\n\n              case 14:\n                this._feeDiscountKeysCache[strOwner] = {\n                  accounts: sortedAccounts,\n                  ts: now\n                };\n                return _context9.abrupt(\"return\", sortedAccounts);\n\n              case 16:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function findFeeDiscountKeys(_x16, _x17) {\n        return _findFeeDiscountKeys.apply(this, arguments);\n      }\n\n      return findFeeDiscountKeys;\n    }()\n  }, {\n    key: \"findBestFeeDiscountKey\",\n    value: function () {\n      var _findBestFeeDiscountKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(connection, ownerAddress) {\n        var cacheDurationMs,\n            accounts,\n            _args10 = arguments;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                cacheDurationMs = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : 30000;\n                _context10.next = 3;\n                return this.findFeeDiscountKeys(connection, ownerAddress, cacheDurationMs);\n\n              case 3:\n                accounts = _context10.sent;\n\n                if (!(accounts.length > 0)) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  pubkey: accounts[0].pubkey,\n                  feeTier: accounts[0].feeTier\n                });\n\n              case 6:\n                return _context10.abrupt(\"return\", {\n                  pubkey: null,\n                  feeTier: 0\n                });\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function findBestFeeDiscountKey(_x18, _x19) {\n        return _findBestFeeDiscountKey.apply(this, arguments);\n      }\n\n      return findBestFeeDiscountKey;\n    }()\n  }, {\n    key: \"makePlaceOrderTransaction\",\n    value: function () {\n      var _makePlaceOrderTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(connection, _ref4) {\n        var owner,\n            payer,\n            side,\n            price,\n            size,\n            _ref4$orderType,\n            orderType,\n            clientId,\n            openOrdersAddressKey,\n            openOrdersAccount,\n            _ref4$feeDiscountPubk,\n            feeDiscountPubkey,\n            _ref4$selfTradeBehavi,\n            selfTradeBehavior,\n            cacheDurationMs,\n            feeDiscountPubkeyCacheDurationMs,\n            _a,\n            _b,\n            ownerAddress,\n            openOrdersAccounts,\n            transaction,\n            signers,\n            useFeeDiscountPubkey,\n            openOrdersAddress,\n            account,\n            wrappedSolAccount,\n            lamports,\n            placeOrderInstruction,\n            _args11 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                owner = _ref4.owner, payer = _ref4.payer, side = _ref4.side, price = _ref4.price, size = _ref4.size, _ref4$orderType = _ref4.orderType, orderType = _ref4$orderType === void 0 ? 'limit' : _ref4$orderType, clientId = _ref4.clientId, openOrdersAddressKey = _ref4.openOrdersAddressKey, openOrdersAccount = _ref4.openOrdersAccount, _ref4$feeDiscountPubk = _ref4.feeDiscountPubkey, feeDiscountPubkey = _ref4$feeDiscountPubk === void 0 ? undefined : _ref4$feeDiscountPubk, _ref4$selfTradeBehavi = _ref4.selfTradeBehavior, selfTradeBehavior = _ref4$selfTradeBehavi === void 0 ? 'decrementTake' : _ref4$selfTradeBehavi;\n                cacheDurationMs = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : 0;\n                feeDiscountPubkeyCacheDurationMs = _args11.length > 3 && _args11[3] !== undefined ? _args11[3] : 0;\n                // @ts-ignore\n                ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;\n                _context11.next = 6;\n                return this.findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs);\n\n              case 6:\n                openOrdersAccounts = _context11.sent;\n                transaction = new web3_js_1.Transaction();\n                signers = []; // Fetch an SRM fee discount key if the market supports discounts and it is not supplied\n\n                if (!feeDiscountPubkey) {\n                  _context11.next = 13;\n                  break;\n                }\n\n                useFeeDiscountPubkey = feeDiscountPubkey;\n                _context11.next = 20;\n                break;\n\n              case 13:\n                if (!(feeDiscountPubkey === undefined && this.supportsSrmFeeDiscounts)) {\n                  _context11.next = 19;\n                  break;\n                }\n\n                _context11.next = 16;\n                return this.findBestFeeDiscountKey(connection, ownerAddress, feeDiscountPubkeyCacheDurationMs);\n\n              case 16:\n                useFeeDiscountPubkey = _context11.sent.pubkey;\n                _context11.next = 20;\n                break;\n\n              case 19:\n                useFeeDiscountPubkey = null;\n\n              case 20:\n                if (!(openOrdersAccounts.length === 0)) {\n                  _context11.next = 32;\n                  break;\n                }\n\n                if (openOrdersAccount) {\n                  account = openOrdersAccount;\n                } else {\n                  account = new web3_js_1.Account();\n                }\n\n                _context11.t0 = transaction;\n                _context11.next = 25;\n                return OpenOrders.makeCreateAccountTransaction(connection, this.address, ownerAddress, account.publicKey, this._programId);\n\n              case 25:\n                _context11.t1 = _context11.sent;\n\n                _context11.t0.add.call(_context11.t0, _context11.t1);\n\n                openOrdersAddress = account.publicKey;\n                signers.push(account); // refresh the cache of open order accounts on next fetch\n\n                this._openOrdersAccountsCache[ownerAddress.toBase58()].ts = 0;\n                _context11.next = 33;\n                break;\n\n              case 32:\n                if (openOrdersAccount) {\n                  openOrdersAddress = openOrdersAccount.publicKey;\n                } else if (openOrdersAddressKey) {\n                  openOrdersAddress = openOrdersAddressKey;\n                } else {\n                  openOrdersAddress = openOrdersAccounts[0].address;\n                }\n\n              case 33:\n                wrappedSolAccount = null;\n\n                if (!payer.equals(ownerAddress)) {\n                  _context11.next = 45;\n                  break;\n                }\n\n                if (!(side === 'buy' && this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) || side === 'sell' && this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT))) {\n                  _context11.next = 44;\n                  break;\n                }\n\n                wrappedSolAccount = new web3_js_1.Account();\n\n                if (side === 'buy') {\n                  lamports = Math.round(price * size * 1.01 * web3_js_1.LAMPORTS_PER_SOL);\n\n                  if (openOrdersAccounts.length > 0) {\n                    lamports -= openOrdersAccounts[0].quoteTokenFree.toNumber();\n                  }\n                } else {\n                  lamports = Math.round(size * web3_js_1.LAMPORTS_PER_SOL);\n\n                  if (openOrdersAccounts.length > 0) {\n                    lamports -= openOrdersAccounts[0].baseTokenFree.toNumber();\n                  }\n                }\n\n                lamports = Math.max(lamports, 0) + 1e7;\n                transaction.add(web3_js_1.SystemProgram.createAccount({\n                  fromPubkey: ownerAddress,\n                  newAccountPubkey: wrappedSolAccount.publicKey,\n                  lamports: lamports,\n                  space: 165,\n                  programId: token_instructions_1.TOKEN_PROGRAM_ID\n                }));\n                transaction.add(token_instructions_1.initializeAccount({\n                  account: wrappedSolAccount.publicKey,\n                  mint: token_instructions_1.WRAPPED_SOL_MINT,\n                  owner: ownerAddress\n                }));\n                signers.push(wrappedSolAccount);\n                _context11.next = 45;\n                break;\n\n              case 44:\n                throw new Error('Invalid payer account');\n\n              case 45:\n                placeOrderInstruction = this.makePlaceOrderInstruction(connection, {\n                  owner: owner,\n                  payer: (_b = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _b !== void 0 ? _b : payer,\n                  side: side,\n                  price: price,\n                  size: size,\n                  orderType: orderType,\n                  clientId: clientId,\n                  openOrdersAddressKey: openOrdersAddress,\n                  feeDiscountPubkey: useFeeDiscountPubkey,\n                  selfTradeBehavior: selfTradeBehavior\n                });\n                transaction.add(placeOrderInstruction);\n\n                if (wrappedSolAccount) {\n                  transaction.add(token_instructions_1.closeAccount({\n                    source: wrappedSolAccount.publicKey,\n                    destination: ownerAddress,\n                    owner: ownerAddress\n                  }));\n                }\n\n                return _context11.abrupt(\"return\", {\n                  transaction: transaction,\n                  signers: signers,\n                  payer: owner\n                });\n\n              case 49:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function makePlaceOrderTransaction(_x20, _x21) {\n        return _makePlaceOrderTransaction.apply(this, arguments);\n      }\n\n      return makePlaceOrderTransaction;\n    }()\n  }, {\n    key: \"makePlaceOrderInstruction\",\n    value: function makePlaceOrderInstruction(connection, _ref5) {\n      var owner = _ref5.owner,\n          payer = _ref5.payer,\n          side = _ref5.side,\n          price = _ref5.price,\n          size = _ref5.size,\n          _ref5$orderType = _ref5.orderType,\n          orderType = _ref5$orderType === void 0 ? 'limit' : _ref5$orderType,\n          clientId = _ref5.clientId,\n          openOrdersAddressKey = _ref5.openOrdersAddressKey,\n          openOrdersAccount = _ref5.openOrdersAccount,\n          _ref5$feeDiscountPubk = _ref5.feeDiscountPubkey,\n          feeDiscountPubkey = _ref5$feeDiscountPubk === void 0 ? null : _ref5$feeDiscountPubk,\n          _ref5$selfTradeBehavi = _ref5.selfTradeBehavior,\n          selfTradeBehavior = _ref5$selfTradeBehavi === void 0 ? 'decrementTake' : _ref5$selfTradeBehavi;\n\n      var _a; // @ts-ignore\n\n\n      var ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;\n\n      if (this.baseSizeNumberToLots(size).lte(new bn_js_1.default(0))) {\n        throw new Error('size too small');\n      }\n\n      if (this.priceNumberToLots(price).lte(new bn_js_1.default(0))) {\n        throw new Error('invalid price');\n      }\n\n      if (!this.supportsSrmFeeDiscounts) {\n        feeDiscountPubkey = null;\n      }\n\n      if (this.usesRequestQueue) {\n        return instructions_1.DexInstructions.newOrder({\n          market: this.address,\n          requestQueue: this._decoded.requestQueue,\n          baseVault: this._decoded.baseVault,\n          quoteVault: this._decoded.quoteVault,\n          openOrders: openOrdersAccount ? openOrdersAccount.publicKey : openOrdersAddressKey,\n          owner: ownerAddress,\n          payer: payer,\n          side: side,\n          limitPrice: this.priceNumberToLots(price),\n          maxQuantity: this.baseSizeNumberToLots(size),\n          orderType: orderType,\n          clientId: clientId,\n          programId: this._programId,\n          feeDiscountPubkey: feeDiscountPubkey\n        });\n      } else {\n        return instructions_1.DexInstructions.newOrderV3({\n          market: this.address,\n          bids: this._decoded.bids,\n          asks: this._decoded.asks,\n          requestQueue: this._decoded.requestQueue,\n          eventQueue: this._decoded.eventQueue,\n          baseVault: this._decoded.baseVault,\n          quoteVault: this._decoded.quoteVault,\n          openOrders: openOrdersAccount ? openOrdersAccount.publicKey : openOrdersAddressKey,\n          owner: ownerAddress,\n          payer: payer,\n          side: side,\n          limitPrice: this.priceNumberToLots(price),\n          maxBaseQuantity: this.baseSizeNumberToLots(size),\n          maxQuoteQuantity: new bn_js_1.default(this._decoded.quoteLotSize.toNumber()).mul(this.baseSizeNumberToLots(size).mul(this.priceNumberToLots(price))),\n          orderType: orderType,\n          clientId: clientId,\n          programId: this._programId,\n          selfTradeBehavior: selfTradeBehavior,\n          feeDiscountPubkey: feeDiscountPubkey\n        });\n      }\n    }\n  }, {\n    key: \"_sendTransaction\",\n    value: function () {\n      var _sendTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(connection, transaction, signers) {\n        var signature, _yield$connection$con, value;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return connection.sendTransaction(transaction, signers, {\n                  skipPreflight: this._skipPreflight\n                });\n\n              case 2:\n                signature = _context12.sent;\n                _context12.next = 5;\n                return connection.confirmTransaction(signature, this._commitment);\n\n              case 5:\n                _yield$connection$con = _context12.sent;\n                value = _yield$connection$con.value;\n\n                if (!(value === null || value === void 0 ? void 0 : value.err)) {\n                  _context12.next = 9;\n                  break;\n                }\n\n                throw new Error(JSON.stringify(value.err));\n\n              case 9:\n                return _context12.abrupt(\"return\", signature);\n\n              case 10:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _sendTransaction(_x22, _x23, _x24) {\n        return _sendTransaction2.apply(this, arguments);\n      }\n\n      return _sendTransaction;\n    }()\n  }, {\n    key: \"cancelOrderByClientId\",\n    value: function () {\n      var _cancelOrderByClientId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(connection, owner, openOrders, clientId) {\n        var transaction;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.makeCancelOrderByClientIdTransaction(connection, owner.publicKey, openOrders, clientId);\n\n              case 2:\n                transaction = _context13.sent;\n                _context13.next = 5;\n                return this._sendTransaction(connection, transaction, [owner]);\n\n              case 5:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function cancelOrderByClientId(_x25, _x26, _x27, _x28) {\n        return _cancelOrderByClientId.apply(this, arguments);\n      }\n\n      return cancelOrderByClientId;\n    }()\n  }, {\n    key: \"makeCancelOrderByClientIdTransaction\",\n    value: function () {\n      var _makeCancelOrderByClientIdTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(connection, owner, openOrders, clientId) {\n        var transaction;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                transaction = new web3_js_1.Transaction();\n\n                if (this.usesRequestQueue) {\n                  transaction.add(instructions_1.DexInstructions.cancelOrderByClientId({\n                    market: this.address,\n                    owner: owner,\n                    openOrders: openOrders,\n                    requestQueue: this._decoded.requestQueue,\n                    clientId: clientId,\n                    programId: this._programId\n                  }));\n                } else {\n                  transaction.add(instructions_1.DexInstructions.cancelOrderByClientIdV2({\n                    market: this.address,\n                    openOrders: openOrders,\n                    owner: owner,\n                    bids: this._decoded.bids,\n                    asks: this._decoded.asks,\n                    eventQueue: this._decoded.eventQueue,\n                    clientId: clientId,\n                    programId: this._programId\n                  }));\n                }\n\n                return _context14.abrupt(\"return\", transaction);\n\n              case 3:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function makeCancelOrderByClientIdTransaction(_x29, _x30, _x31, _x32) {\n        return _makeCancelOrderByClientIdTransaction.apply(this, arguments);\n      }\n\n      return makeCancelOrderByClientIdTransaction;\n    }()\n  }, {\n    key: \"cancelOrder\",\n    value: function () {\n      var _cancelOrder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(connection, owner, order) {\n        var transaction;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.makeCancelOrderTransaction(connection, owner.publicKey, order);\n\n              case 2:\n                transaction = _context15.sent;\n                _context15.next = 5;\n                return this._sendTransaction(connection, transaction, [owner]);\n\n              case 5:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 6:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function cancelOrder(_x33, _x34, _x35) {\n        return _cancelOrder.apply(this, arguments);\n      }\n\n      return cancelOrder;\n    }()\n  }, {\n    key: \"makeCancelOrderTransaction\",\n    value: function () {\n      var _makeCancelOrderTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(connection, owner, order) {\n        var transaction;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                transaction = new web3_js_1.Transaction();\n                transaction.add(this.makeCancelOrderInstruction(connection, owner, order));\n                return _context16.abrupt(\"return\", transaction);\n\n              case 3:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function makeCancelOrderTransaction(_x36, _x37, _x38) {\n        return _makeCancelOrderTransaction.apply(this, arguments);\n      }\n\n      return makeCancelOrderTransaction;\n    }()\n  }, {\n    key: \"makeCancelOrderInstruction\",\n    value: function makeCancelOrderInstruction(connection, owner, order) {\n      if (this.usesRequestQueue) {\n        return instructions_1.DexInstructions.cancelOrder({\n          market: this.address,\n          owner: owner,\n          openOrders: order.openOrdersAddress,\n          requestQueue: this._decoded.requestQueue,\n          side: order.side,\n          orderId: order.orderId,\n          openOrdersSlot: order.openOrdersSlot,\n          programId: this._programId\n        });\n      } else {\n        return instructions_1.DexInstructions.cancelOrderV2({\n          market: this.address,\n          owner: owner,\n          openOrders: order.openOrdersAddress,\n          bids: this._decoded.bids,\n          asks: this._decoded.asks,\n          eventQueue: this._decoded.eventQueue,\n          side: order.side,\n          orderId: order.orderId,\n          openOrdersSlot: order.openOrdersSlot,\n          programId: this._programId\n        });\n      }\n    }\n  }, {\n    key: \"settleFunds\",\n    value: function () {\n      var _settleFunds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(connection, owner, openOrders, baseWallet, quoteWallet) {\n        var referrerQuoteWallet,\n            _yield$this$makeSettl,\n            transaction,\n            signers,\n            _args17 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                referrerQuoteWallet = _args17.length > 5 && _args17[5] !== undefined ? _args17[5] : null;\n\n                if (openOrders.owner.equals(owner.publicKey)) {\n                  _context17.next = 3;\n                  break;\n                }\n\n                throw new Error('Invalid open orders account');\n\n              case 3:\n                if (!(referrerQuoteWallet && !this.supportsReferralFees)) {\n                  _context17.next = 5;\n                  break;\n                }\n\n                throw new Error('This program ID does not support referrerQuoteWallet');\n\n              case 5:\n                _context17.next = 7;\n                return this.makeSettleFundsTransaction(connection, openOrders, baseWallet, quoteWallet, referrerQuoteWallet);\n\n              case 7:\n                _yield$this$makeSettl = _context17.sent;\n                transaction = _yield$this$makeSettl.transaction;\n                signers = _yield$this$makeSettl.signers;\n                _context17.next = 12;\n                return this._sendTransaction(connection, transaction, [owner].concat(_toConsumableArray(signers)));\n\n              case 12:\n                return _context17.abrupt(\"return\", _context17.sent);\n\n              case 13:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function settleFunds(_x39, _x40, _x41, _x42, _x43) {\n        return _settleFunds.apply(this, arguments);\n      }\n\n      return settleFunds;\n    }()\n  }, {\n    key: \"makeSettleFundsTransaction\",\n    value: function () {\n      var _makeSettleFundsTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(connection, openOrders, baseWallet, quoteWallet) {\n        var referrerQuoteWallet,\n            vaultSigner,\n            transaction,\n            signers,\n            wrappedSolAccount,\n            _args18 = arguments;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                referrerQuoteWallet = _args18.length > 4 && _args18[4] !== undefined ? _args18[4] : null;\n                _context18.next = 3;\n                return web3_js_1.PublicKey.createProgramAddress([this.address.toBuffer(), this._decoded.vaultSignerNonce.toArrayLike(buffer_1.Buffer, 'le', 8)], this._programId);\n\n              case 3:\n                vaultSigner = _context18.sent;\n                transaction = new web3_js_1.Transaction();\n                signers = [];\n                wrappedSolAccount = null;\n\n                if (!(this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && baseWallet.equals(openOrders.owner) || this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && quoteWallet.equals(openOrders.owner))) {\n                  _context18.next = 22;\n                  break;\n                }\n\n                wrappedSolAccount = new web3_js_1.Account();\n                _context18.t0 = transaction;\n                _context18.t1 = web3_js_1.SystemProgram;\n                _context18.t2 = openOrders.owner;\n                _context18.t3 = wrappedSolAccount.publicKey;\n                _context18.next = 15;\n                return connection.getMinimumBalanceForRentExemption(165);\n\n              case 15:\n                _context18.t4 = _context18.sent;\n                _context18.t5 = token_instructions_1.TOKEN_PROGRAM_ID;\n                _context18.t6 = {\n                  fromPubkey: _context18.t2,\n                  newAccountPubkey: _context18.t3,\n                  lamports: _context18.t4,\n                  space: 165,\n                  programId: _context18.t5\n                };\n                _context18.t7 = _context18.t1.createAccount.call(_context18.t1, _context18.t6);\n\n                _context18.t0.add.call(_context18.t0, _context18.t7);\n\n                transaction.add(token_instructions_1.initializeAccount({\n                  account: wrappedSolAccount.publicKey,\n                  mint: token_instructions_1.WRAPPED_SOL_MINT,\n                  owner: openOrders.owner\n                }));\n                signers.push(wrappedSolAccount);\n\n              case 22:\n                transaction.add(instructions_1.DexInstructions.settleFunds({\n                  market: this.address,\n                  openOrders: openOrders.address,\n                  owner: openOrders.owner,\n                  baseVault: this._decoded.baseVault,\n                  quoteVault: this._decoded.quoteVault,\n                  baseWallet: baseWallet.equals(openOrders.owner) && wrappedSolAccount ? wrappedSolAccount.publicKey : baseWallet,\n                  quoteWallet: quoteWallet.equals(openOrders.owner) && wrappedSolAccount ? wrappedSolAccount.publicKey : quoteWallet,\n                  vaultSigner: vaultSigner,\n                  programId: this._programId,\n                  referrerQuoteWallet: referrerQuoteWallet\n                }));\n\n                if (wrappedSolAccount) {\n                  transaction.add(token_instructions_1.closeAccount({\n                    source: wrappedSolAccount.publicKey,\n                    destination: openOrders.owner,\n                    owner: openOrders.owner\n                  }));\n                }\n\n                return _context18.abrupt(\"return\", {\n                  transaction: transaction,\n                  signers: signers,\n                  payer: openOrders.owner\n                });\n\n              case 25:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function makeSettleFundsTransaction(_x44, _x45, _x46, _x47) {\n        return _makeSettleFundsTransaction.apply(this, arguments);\n      }\n\n      return makeSettleFundsTransaction;\n    }()\n  }, {\n    key: \"matchOrders\",\n    value: function () {\n      var _matchOrders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(connection, feePayer, limit) {\n        var tx;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                tx = this.makeMatchOrdersTransaction(limit);\n                _context19.next = 3;\n                return this._sendTransaction(connection, tx, [feePayer]);\n\n              case 3:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 4:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function matchOrders(_x48, _x49, _x50) {\n        return _matchOrders.apply(this, arguments);\n      }\n\n      return matchOrders;\n    }()\n  }, {\n    key: \"makeMatchOrdersTransaction\",\n    value: function makeMatchOrdersTransaction(limit) {\n      var tx = new web3_js_1.Transaction();\n      tx.add(instructions_1.DexInstructions.matchOrders({\n        market: this.address,\n        requestQueue: this._decoded.requestQueue,\n        eventQueue: this._decoded.eventQueue,\n        bids: this._decoded.bids,\n        asks: this._decoded.asks,\n        baseVault: this._decoded.baseVault,\n        quoteVault: this._decoded.quoteVault,\n        limit: limit,\n        programId: this._programId\n      }));\n      return tx;\n    }\n  }, {\n    key: \"loadRequestQueue\",\n    value: function () {\n      var _loadRequestQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(connection) {\n        var _throwIfNull3, data;\n\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.t0 = throwIfNull;\n                _context20.next = 3;\n                return connection.getAccountInfo(this._decoded.requestQueue);\n\n              case 3:\n                _context20.t1 = _context20.sent;\n                _throwIfNull3 = (0, _context20.t0)(_context20.t1);\n                data = _throwIfNull3.data;\n                return _context20.abrupt(\"return\", queue_1.decodeRequestQueue(data));\n\n              case 7:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function loadRequestQueue(_x51) {\n        return _loadRequestQueue.apply(this, arguments);\n      }\n\n      return loadRequestQueue;\n    }()\n  }, {\n    key: \"loadEventQueue\",\n    value: function () {\n      var _loadEventQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(connection) {\n        var _throwIfNull4, data;\n\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.t0 = throwIfNull;\n                _context21.next = 3;\n                return connection.getAccountInfo(this._decoded.eventQueue);\n\n              case 3:\n                _context21.t1 = _context21.sent;\n                _throwIfNull4 = (0, _context21.t0)(_context21.t1);\n                data = _throwIfNull4.data;\n                return _context21.abrupt(\"return\", queue_1.decodeEventQueue(data));\n\n              case 7:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function loadEventQueue(_x52) {\n        return _loadEventQueue.apply(this, arguments);\n      }\n\n      return loadEventQueue;\n    }()\n  }, {\n    key: \"loadFills\",\n    value: function () {\n      var _loadFills = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(connection) {\n        var limit,\n            _throwIfNull5,\n            data,\n            events,\n            _args22 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                limit = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : 100;\n                _context22.t0 = throwIfNull;\n                _context22.next = 4;\n                return connection.getAccountInfo(this._decoded.eventQueue);\n\n              case 4:\n                _context22.t1 = _context22.sent;\n                _throwIfNull5 = (0, _context22.t0)(_context22.t1);\n                data = _throwIfNull5.data;\n                events = queue_1.decodeEventQueue(data, limit);\n                return _context22.abrupt(\"return\", events.filter(function (event) {\n                  return event.eventFlags.fill && event.nativeQuantityPaid.gtn(0);\n                }).map(this.parseFillEvent.bind(this)));\n\n              case 9:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function loadFills(_x53) {\n        return _loadFills.apply(this, arguments);\n      }\n\n      return loadFills;\n    }()\n  }, {\n    key: \"parseFillEvent\",\n    value: function parseFillEvent(event) {\n      var size, price, side, priceBeforeFees;\n\n      if (event.eventFlags.bid) {\n        side = 'buy';\n        priceBeforeFees = event.eventFlags.maker ? event.nativeQuantityPaid.add(event.nativeFeeOrRebate) : event.nativeQuantityPaid.sub(event.nativeFeeOrRebate);\n        price = divideBnToNumber(priceBeforeFees.mul(this._baseSplTokenMultiplier), this._quoteSplTokenMultiplier.mul(event.nativeQuantityReleased));\n        size = divideBnToNumber(event.nativeQuantityReleased, this._baseSplTokenMultiplier);\n      } else {\n        side = 'sell';\n        priceBeforeFees = event.eventFlags.maker ? event.nativeQuantityReleased.sub(event.nativeFeeOrRebate) : event.nativeQuantityReleased.add(event.nativeFeeOrRebate);\n        price = divideBnToNumber(priceBeforeFees.mul(this._baseSplTokenMultiplier), this._quoteSplTokenMultiplier.mul(event.nativeQuantityPaid));\n        size = divideBnToNumber(event.nativeQuantityPaid, this._baseSplTokenMultiplier);\n      }\n\n      return _objectSpread(_objectSpread({}, event), {}, {\n        side: side,\n        price: price,\n        feeCost: this.quoteSplSizeToNumber(event.nativeFeeOrRebate) * (event.eventFlags.maker ? -1 : 1),\n        size: size\n      });\n    }\n  }, {\n    key: \"priceLotsToNumber\",\n    value: function priceLotsToNumber(price) {\n      return divideBnToNumber(price.mul(this._decoded.quoteLotSize).mul(this._baseSplTokenMultiplier), this._decoded.baseLotSize.mul(this._quoteSplTokenMultiplier));\n    }\n  }, {\n    key: \"priceNumberToLots\",\n    value: function priceNumberToLots(price) {\n      return new bn_js_1.default(Math.round(price * Math.pow(10, this._quoteSplTokenDecimals) * this._decoded.baseLotSize.toNumber() / (Math.pow(10, this._baseSplTokenDecimals) * this._decoded.quoteLotSize.toNumber())));\n    }\n  }, {\n    key: \"baseSplSizeToNumber\",\n    value: function baseSplSizeToNumber(size) {\n      return divideBnToNumber(size, this._baseSplTokenMultiplier);\n    }\n  }, {\n    key: \"quoteSplSizeToNumber\",\n    value: function quoteSplSizeToNumber(size) {\n      return divideBnToNumber(size, this._quoteSplTokenMultiplier);\n    }\n  }, {\n    key: \"baseSizeLotsToNumber\",\n    value: function baseSizeLotsToNumber(size) {\n      return divideBnToNumber(size.mul(this._decoded.baseLotSize), this._baseSplTokenMultiplier);\n    }\n  }, {\n    key: \"baseSizeNumberToLots\",\n    value: function baseSizeNumberToLots(size) {\n      var native = new bn_js_1.default(Math.round(size * Math.pow(10, this._baseSplTokenDecimals))); // rounds down to the nearest lot size\n\n      return native.div(this._decoded.baseLotSize);\n    }\n  }, {\n    key: \"quoteSizeLotsToNumber\",\n    value: function quoteSizeLotsToNumber(size) {\n      return divideBnToNumber(size.mul(this._decoded.quoteLotSize), this._quoteSplTokenMultiplier);\n    }\n  }, {\n    key: \"quoteSizeNumberToLots\",\n    value: function quoteSizeNumberToLots(size) {\n      var native = new bn_js_1.default(Math.round(size * Math.pow(10, this._quoteSplTokenDecimals))); // rounds down to the nearest lot size\n\n      return native.div(this._decoded.quoteLotSize);\n    }\n  }, {\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n  }, {\n    key: \"address\",\n    get: function get() {\n      return this._decoded.ownAddress;\n    }\n  }, {\n    key: \"publicKey\",\n    get: function get() {\n      return this.address;\n    }\n  }, {\n    key: \"baseMintAddress\",\n    get: function get() {\n      return this._decoded.baseMint;\n    }\n  }, {\n    key: \"quoteMintAddress\",\n    get: function get() {\n      return this._decoded.quoteMint;\n    }\n  }, {\n    key: \"bidsAddress\",\n    get: function get() {\n      return this._decoded.bids;\n    }\n  }, {\n    key: \"asksAddress\",\n    get: function get() {\n      return this._decoded.asks;\n    }\n  }, {\n    key: \"supportsSrmFeeDiscounts\",\n    get: function get() {\n      return fees_1.supportsSrmFeeDiscounts(this._programId);\n    }\n  }, {\n    key: \"supportsReferralFees\",\n    get: function get() {\n      return tokens_and_markets_1.getLayoutVersion(this._programId) > 1;\n    }\n  }, {\n    key: \"usesRequestQueue\",\n    get: function get() {\n      return tokens_and_markets_1.getLayoutVersion(this._programId) <= 2;\n    }\n  }, {\n    key: \"_baseSplTokenMultiplier\",\n    get: function get() {\n      return new bn_js_1.default(10).pow(new bn_js_1.default(this._baseSplTokenDecimals));\n    }\n  }, {\n    key: \"_quoteSplTokenMultiplier\",\n    get: function get() {\n      return new bn_js_1.default(10).pow(new bn_js_1.default(this._quoteSplTokenDecimals));\n    }\n  }, {\n    key: \"minOrderSize\",\n    get: function get() {\n      return this.baseSizeLotsToNumber(new bn_js_1.default(1));\n    }\n  }, {\n    key: \"tickSize\",\n    get: function get() {\n      return this.priceLotsToNumber(new bn_js_1.default(1));\n    }\n  }], [{\n    key: \"getLayout\",\n    value: function getLayout(programId) {\n      if (tokens_and_markets_1.getLayoutVersion(programId) === 1) {\n        return exports._MARKET_STAT_LAYOUT_V1;\n      }\n\n      return exports._MARKET_STATE_LAYOUT_V2;\n    }\n  }, {\n    key: \"findAccountsByMints\",\n    value: function () {\n      var _findAccountsByMints = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(connection, baseMintAddress, quoteMintAddress, programId) {\n        var filters;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                filters = [{\n                  memcmp: {\n                    offset: this.getLayout(programId).offsetOf('baseMint'),\n                    bytes: baseMintAddress.toBase58()\n                  }\n                }, {\n                  memcmp: {\n                    offset: Market.getLayout(programId).offsetOf('quoteMint'),\n                    bytes: quoteMintAddress.toBase58()\n                  }\n                }];\n                return _context23.abrupt(\"return\", getFilteredProgramAccounts(connection, programId, filters));\n\n              case 2:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function findAccountsByMints(_x54, _x55, _x56, _x57) {\n        return _findAccountsByMints.apply(this, arguments);\n      }\n\n      return findAccountsByMints;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(connection, address) {\n        var options,\n            programId,\n            _throwIfNull6,\n            owner,\n            data,\n            decoded,\n            _yield$Promise$all7,\n            _yield$Promise$all8,\n            baseMintDecimals,\n            quoteMintDecimals,\n            _args24 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                options = _args24.length > 2 && _args24[2] !== undefined ? _args24[2] : {};\n                programId = _args24.length > 3 ? _args24[3] : undefined;\n                _context24.t0 = throwIfNull;\n                _context24.next = 5;\n                return connection.getAccountInfo(address);\n\n              case 5:\n                _context24.t1 = _context24.sent;\n                _throwIfNull6 = (0, _context24.t0)(_context24.t1, 'Market not found');\n                owner = _throwIfNull6.owner;\n                data = _throwIfNull6.data;\n\n                if (owner.equals(programId)) {\n                  _context24.next = 11;\n                  break;\n                }\n\n                throw new Error('Address not owned by program: ' + owner.toBase58());\n\n              case 11:\n                decoded = this.getLayout(programId).decode(data);\n\n                if (!(!decoded.accountFlags.initialized || !decoded.accountFlags.market || !decoded.ownAddress.equals(address))) {\n                  _context24.next = 14;\n                  break;\n                }\n\n                throw new Error('Invalid market');\n\n              case 14:\n                _context24.next = 16;\n                return Promise.all([getMintDecimals(connection, decoded.baseMint), getMintDecimals(connection, decoded.quoteMint)]);\n\n              case 16:\n                _yield$Promise$all7 = _context24.sent;\n                _yield$Promise$all8 = _slicedToArray(_yield$Promise$all7, 2);\n                baseMintDecimals = _yield$Promise$all8[0];\n                quoteMintDecimals = _yield$Promise$all8[1];\n                return _context24.abrupt(\"return\", new Market(decoded, baseMintDecimals, quoteMintDecimals, options, programId));\n\n              case 21:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function load(_x58, _x59) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }]);\n\n  return Market;\n}();\n\nexports.Market = Market;\nexports._OPEN_ORDERS_LAYOUT_V1 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('market'), layout_1.publicKeyLayout('owner'), // These are in spl-token (i.e. not lot) units\nlayout_1.u64('baseTokenFree'), layout_1.u64('baseTokenTotal'), layout_1.u64('quoteTokenFree'), layout_1.u64('quoteTokenTotal'), layout_1.u128('freeSlotBits'), layout_1.u128('isBidBits'), buffer_layout_1.seq(layout_1.u128(), 128, 'orders'), buffer_layout_1.seq(layout_1.u64(), 128, 'clientIds'), buffer_layout_1.blob(7)]);\nexports._OPEN_ORDERS_LAYOUT_V2 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('market'), layout_1.publicKeyLayout('owner'), // These are in spl-token (i.e. not lot) units\nlayout_1.u64('baseTokenFree'), layout_1.u64('baseTokenTotal'), layout_1.u64('quoteTokenFree'), layout_1.u64('quoteTokenTotal'), layout_1.u128('freeSlotBits'), layout_1.u128('isBidBits'), buffer_layout_1.seq(layout_1.u128(), 128, 'orders'), buffer_layout_1.seq(layout_1.u64(), 128, 'clientIds'), layout_1.u64('referrerRebatesAccrued'), buffer_layout_1.blob(7)]);\n\nvar OpenOrders = /*#__PURE__*/function () {\n  function OpenOrders(address, decoded, programId) {\n    _classCallCheck(this, OpenOrders);\n\n    this.address = address;\n    this._programId = programId;\n    Object.assign(this, decoded);\n  }\n\n  _createClass(OpenOrders, [{\n    key: \"publicKey\",\n    get: function get() {\n      return this.address;\n    }\n  }], [{\n    key: \"getLayout\",\n    value: function getLayout(programId) {\n      if (tokens_and_markets_1.getLayoutVersion(programId) === 1) {\n        return exports._OPEN_ORDERS_LAYOUT_V1;\n      }\n\n      return exports._OPEN_ORDERS_LAYOUT_V2;\n    }\n  }, {\n    key: \"findForOwner\",\n    value: function () {\n      var _findForOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(connection, ownerAddress, programId) {\n        var filters, accounts;\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                filters = [{\n                  memcmp: {\n                    offset: this.getLayout(programId).offsetOf('owner'),\n                    bytes: ownerAddress.toBase58()\n                  }\n                }, {\n                  dataSize: this.getLayout(programId).span\n                }];\n                _context25.next = 3;\n                return getFilteredProgramAccounts(connection, programId, filters);\n\n              case 3:\n                accounts = _context25.sent;\n                return _context25.abrupt(\"return\", accounts.map(function (_ref6) {\n                  var publicKey = _ref6.publicKey,\n                      accountInfo = _ref6.accountInfo;\n                  return OpenOrders.fromAccountInfo(publicKey, accountInfo, programId);\n                }));\n\n              case 5:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function findForOwner(_x60, _x61, _x62) {\n        return _findForOwner.apply(this, arguments);\n      }\n\n      return findForOwner;\n    }()\n  }, {\n    key: \"findForMarketAndOwner\",\n    value: function () {\n      var _findForMarketAndOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(connection, marketAddress, ownerAddress, programId) {\n        var filters, accounts;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                filters = [{\n                  memcmp: {\n                    offset: this.getLayout(programId).offsetOf('market'),\n                    bytes: marketAddress.toBase58()\n                  }\n                }, {\n                  memcmp: {\n                    offset: this.getLayout(programId).offsetOf('owner'),\n                    bytes: ownerAddress.toBase58()\n                  }\n                }, {\n                  dataSize: this.getLayout(programId).span\n                }];\n                _context26.next = 3;\n                return getFilteredProgramAccounts(connection, programId, filters);\n\n              case 3:\n                accounts = _context26.sent;\n                return _context26.abrupt(\"return\", accounts.map(function (_ref7) {\n                  var publicKey = _ref7.publicKey,\n                      accountInfo = _ref7.accountInfo;\n                  return OpenOrders.fromAccountInfo(publicKey, accountInfo, programId);\n                }));\n\n              case 5:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function findForMarketAndOwner(_x63, _x64, _x65, _x66) {\n        return _findForMarketAndOwner.apply(this, arguments);\n      }\n\n      return findForMarketAndOwner;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(connection, address, programId) {\n        var accountInfo;\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return connection.getAccountInfo(address);\n\n              case 2:\n                accountInfo = _context27.sent;\n\n                if (!(accountInfo === null)) {\n                  _context27.next = 5;\n                  break;\n                }\n\n                throw new Error('Open orders account not found');\n\n              case 5:\n                return _context27.abrupt(\"return\", OpenOrders.fromAccountInfo(address, accountInfo, programId));\n\n              case 6:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27);\n      }));\n\n      function load(_x67, _x68, _x69) {\n        return _load2.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"fromAccountInfo\",\n    value: function fromAccountInfo(address, accountInfo, programId) {\n      var owner = accountInfo.owner,\n          data = accountInfo.data;\n\n      if (!owner.equals(programId)) {\n        throw new Error('Address not owned by program');\n      }\n\n      var decoded = this.getLayout(programId).decode(data);\n\n      if (!decoded.accountFlags.initialized || !decoded.accountFlags.openOrders) {\n        throw new Error('Invalid open orders account');\n      }\n\n      return new OpenOrders(address, decoded, programId);\n    }\n  }, {\n    key: \"makeCreateAccountTransaction\",\n    value: function () {\n      var _makeCreateAccountTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28(connection, marketAddress, ownerAddress, newAccountAddress, programId) {\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.t0 = web3_js_1.SystemProgram;\n                _context28.t1 = ownerAddress;\n                _context28.t2 = newAccountAddress;\n                _context28.next = 5;\n                return connection.getMinimumBalanceForRentExemption(this.getLayout(programId).span);\n\n              case 5:\n                _context28.t3 = _context28.sent;\n                _context28.t4 = this.getLayout(programId).span;\n                _context28.t5 = programId;\n                _context28.t6 = {\n                  fromPubkey: _context28.t1,\n                  newAccountPubkey: _context28.t2,\n                  lamports: _context28.t3,\n                  space: _context28.t4,\n                  programId: _context28.t5\n                };\n                return _context28.abrupt(\"return\", _context28.t0.createAccount.call(_context28.t0, _context28.t6));\n\n              case 10:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function makeCreateAccountTransaction(_x70, _x71, _x72, _x73, _x74) {\n        return _makeCreateAccountTransaction.apply(this, arguments);\n      }\n\n      return makeCreateAccountTransaction;\n    }()\n  }]);\n\n  return OpenOrders;\n}();\n\nexports.OpenOrders = OpenOrders;\nexports.ORDERBOOK_LAYOUT = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), slab_1.SLAB_LAYOUT.replicate('slab'), buffer_layout_1.blob(7)]);\n\nvar Orderbook = /*#__PURE__*/function () {\n  function Orderbook(market, accountFlags, slab) {\n    _classCallCheck(this, Orderbook);\n\n    if (!accountFlags.initialized || !(accountFlags.bids ^ accountFlags.asks)) {\n      throw new Error('Invalid orderbook');\n    }\n\n    this.market = market;\n    this.isBids = accountFlags.bids;\n    this.slab = slab;\n  }\n\n  _createClass(Orderbook, [{\n    key: \"getL2\",\n    value: function getL2(depth) {\n      var _this2 = this;\n\n      var descending = this.isBids;\n      var levels = []; // (price, size)\n\n      var _iterator = _createForOfIteratorHelper(this.slab.items(descending)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _step.value,\n              key = _step$value.key,\n              quantity = _step$value.quantity;\n          var price = getPriceFromKey(key);\n\n          if (levels.length > 0 && levels[levels.length - 1][0].eq(price)) {\n            levels[levels.length - 1][1].iadd(quantity);\n          } else if (levels.length === depth) {\n            break;\n          } else {\n            levels.push([price, quantity]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return levels.map(function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            priceLots = _ref9[0],\n            sizeLots = _ref9[1];\n\n        return [_this2.market.priceLotsToNumber(priceLots), _this2.market.baseSizeLotsToNumber(sizeLots), priceLots, sizeLots];\n      });\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this.items(false);\n    }\n  }, {\n    key: \"items\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function items() {\n      var descending,\n          _iterator2,\n          _step2,\n          _step2$value,\n          key,\n          ownerSlot,\n          owner,\n          quantity,\n          feeTier,\n          clientOrderId,\n          price,\n          _args29 = arguments;\n\n      return _regeneratorRuntime.wrap(function items$(_context29) {\n        while (1) {\n          switch (_context29.prev = _context29.next) {\n            case 0:\n              descending = _args29.length > 0 && _args29[0] !== undefined ? _args29[0] : false;\n              _iterator2 = _createForOfIteratorHelper(this.slab.items(descending));\n              _context29.prev = 2;\n\n              _iterator2.s();\n\n            case 4:\n              if ((_step2 = _iterator2.n()).done) {\n                _context29.next = 11;\n                break;\n              }\n\n              _step2$value = _step2.value, key = _step2$value.key, ownerSlot = _step2$value.ownerSlot, owner = _step2$value.owner, quantity = _step2$value.quantity, feeTier = _step2$value.feeTier, clientOrderId = _step2$value.clientOrderId;\n              price = getPriceFromKey(key);\n              _context29.next = 9;\n              return {\n                orderId: key,\n                clientId: clientOrderId,\n                openOrdersAddress: owner,\n                openOrdersSlot: ownerSlot,\n                feeTier: feeTier,\n                price: this.market.priceLotsToNumber(price),\n                priceLots: price,\n                size: this.market.baseSizeLotsToNumber(quantity),\n                sizeLots: quantity,\n                side: this.isBids ? 'buy' : 'sell'\n              };\n\n            case 9:\n              _context29.next = 4;\n              break;\n\n            case 11:\n              _context29.next = 16;\n              break;\n\n            case 13:\n              _context29.prev = 13;\n              _context29.t0 = _context29[\"catch\"](2);\n\n              _iterator2.e(_context29.t0);\n\n            case 16:\n              _context29.prev = 16;\n\n              _iterator2.f();\n\n              return _context29.finish(16);\n\n            case 19:\n            case \"end\":\n              return _context29.stop();\n          }\n        }\n      }, items, this, [[2, 13, 16, 19]]);\n    })\n  }], [{\n    key: \"decode\",\n    value: function decode(market, buffer) {\n      var _exports$ORDERBOOK_LA = exports.ORDERBOOK_LAYOUT.decode(buffer),\n          accountFlags = _exports$ORDERBOOK_LA.accountFlags,\n          slab = _exports$ORDERBOOK_LA.slab;\n\n      return new Orderbook(market, accountFlags, slab);\n    }\n  }, {\n    key: \"LAYOUT\",\n    get: function get() {\n      return exports.ORDERBOOK_LAYOUT;\n    }\n  }]);\n\n  return Orderbook;\n}();\n\nexports.Orderbook = Orderbook;\n\nfunction getPriceFromKey(key) {\n  return key.ushrn(64);\n}\n\nfunction divideBnToNumber(numerator, denominator) {\n  var quotient = numerator.div(denominator).toNumber();\n  var rem = numerator.umod(denominator);\n  var gcd = rem.gcd(denominator);\n  return quotient + rem.div(gcd).toNumber() / denominator.div(gcd).toNumber();\n}\n\nvar MINT_LAYOUT = buffer_layout_1.struct([buffer_layout_1.blob(44), buffer_layout_1.u8('decimals'), buffer_layout_1.blob(37)]);\n\nfunction getMintDecimals(_x75, _x76) {\n  return _getMintDecimals.apply(this, arguments);\n}\n\nfunction _getMintDecimals() {\n  _getMintDecimals = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(connection, mint) {\n    var _throwIfNull7, data, _MINT_LAYOUT$decode, decimals;\n\n    return _regeneratorRuntime.wrap(function _callee29$(_context30) {\n      while (1) {\n        switch (_context30.prev = _context30.next) {\n          case 0:\n            if (!mint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n              _context30.next = 2;\n              break;\n            }\n\n            return _context30.abrupt(\"return\", 9);\n\n          case 2:\n            _context30.t0 = throwIfNull;\n            _context30.next = 5;\n            return connection.getAccountInfo(mint);\n\n          case 5:\n            _context30.t1 = _context30.sent;\n            _throwIfNull7 = (0, _context30.t0)(_context30.t1, 'mint not found');\n            data = _throwIfNull7.data;\n            _MINT_LAYOUT$decode = MINT_LAYOUT.decode(data), decimals = _MINT_LAYOUT$decode.decimals;\n            return _context30.abrupt(\"return\", decimals);\n\n          case 10:\n          case \"end\":\n            return _context30.stop();\n        }\n      }\n    }, _callee29);\n  }));\n  return _getMintDecimals.apply(this, arguments);\n}\n\nexports.getMintDecimals = getMintDecimals;\n\nfunction getFilteredProgramAccounts(_x77, _x78, _x79) {\n  return _getFilteredProgramAccounts.apply(this, arguments);\n}\n\nfunction _getFilteredProgramAccounts() {\n  _getFilteredProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(connection, programId, filters) {\n    var resp;\n    return _regeneratorRuntime.wrap(function _callee30$(_context31) {\n      while (1) {\n        switch (_context31.prev = _context31.next) {\n          case 0:\n            _context31.next = 2;\n            return connection._rpcRequest('getProgramAccounts', [programId.toBase58(), {\n              commitment: connection.commitment,\n              filters: filters,\n              encoding: 'base64'\n            }]);\n\n          case 2:\n            resp = _context31.sent;\n\n            if (!resp.error) {\n              _context31.next = 5;\n              break;\n            }\n\n            throw new Error(resp.error.message);\n\n          case 5:\n            return _context31.abrupt(\"return\", resp.result.map(function (_ref10) {\n              var pubkey = _ref10.pubkey,\n                  _ref10$account = _ref10.account,\n                  data = _ref10$account.data,\n                  executable = _ref10$account.executable,\n                  owner = _ref10$account.owner,\n                  lamports = _ref10$account.lamports;\n              return {\n                publicKey: new web3_js_1.PublicKey(pubkey),\n                accountInfo: {\n                  data: buffer_1.Buffer.from(data[0], 'base64'),\n                  executable: executable,\n                  owner: new web3_js_1.PublicKey(owner),\n                  lamports: lamports\n                }\n              };\n            }));\n\n          case 6:\n          case \"end\":\n            return _context31.stop();\n        }\n      }\n    }, _callee30);\n  }));\n  return _getFilteredProgramAccounts.apply(this, arguments);\n}\n\nfunction throwIfNull(value) {\n  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'account not found';\n\n  if (value === null) {\n    throw new Error(message);\n  }\n\n  return value;\n}","map":null,"metadata":{},"sourceType":"script"}