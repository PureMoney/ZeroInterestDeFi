{"ast":null,"code":"import _regeneratorRuntime from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _asyncToGenerator from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/home/ctapang/dapp-scaffold/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useLocalStorageState}from\"./../utils/utils\";import{Account,clusterApiUrl,Connection,PublicKey,Transaction}from\"@solana/web3.js\";import React,{useContext,useEffect,useMemo,useState}from\"react\";import{notify}from\"./../utils/notifications\";import{ExplorerLink}from\"../components/ExplorerLink\";import{setProgramIds}from\"../utils/ids\";import{cache,getMultipleAccounts,MintParser}from\"./accounts\";import{TokenListProvider,ENV as ChainID}from\"@solana/spl-token-registry\";export var ENDPOINTS=[{name:\"mainnet-beta\",endpoint:\"https://solana-api.projectserum.com/\",chainID:ChainID.MainnetBeta},{name:\"testnet\",endpoint:clusterApiUrl(\"testnet\"),chainID:ChainID.Testnet},{name:\"devnet\",endpoint:clusterApiUrl(\"devnet\"),chainID:ChainID.Devnet},{name:\"localnet\",endpoint:\"http://127.0.0.1:8899\",chainID:ChainID.Devnet}];var DEFAULT=ENDPOINTS[0].endpoint;var DEFAULT_SLIPPAGE=0.25;var ConnectionContext=React.createContext({endpoint:DEFAULT,setEndpoint:function setEndpoint(){},slippage:DEFAULT_SLIPPAGE,setSlippage:function setSlippage(val){},connection:new Connection(DEFAULT,\"recent\"),sendConnection:new Connection(DEFAULT,\"recent\"),env:ENDPOINTS[0].name,tokens:[],tokenMap:new Map()});export function ConnectionProvider(_ref){var _ref$children=_ref.children,children=_ref$children===void 0?undefined:_ref$children;var _useLocalStorageState=useLocalStorageState(\"connectionEndpts\",ENDPOINTS[0].endpoint),_useLocalStorageState2=_slicedToArray(_useLocalStorageState,2),endpoint=_useLocalStorageState2[0],setEndpoint=_useLocalStorageState2[1];var _useLocalStorageState3=useLocalStorageState(\"slippage\",DEFAULT_SLIPPAGE.toString()),_useLocalStorageState4=_slicedToArray(_useLocalStorageState3,2),slippage=_useLocalStorageState4[0],_setSlippage=_useLocalStorageState4[1];var connection=useMemo(function(){return new Connection(endpoint,\"recent\");},[endpoint]);var sendConnection=useMemo(function(){return new Connection(endpoint,\"recent\");},[endpoint]);var chain=ENDPOINTS.find(function(end){return end.endpoint===endpoint;})||ENDPOINTS[0];var env=chain.name;var _useState=useState([]),_useState2=_slicedToArray(_useState,2),tokens=_useState2[0],setTokens=_useState2[1];var _useState3=useState(new Map()),_useState4=_slicedToArray(_useState3,2),tokenMap=_useState4[0],setTokenMap=_useState4[1];useEffect(function(){cache.clear();// fetch token files\n_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var res,list,knownMints,accounts;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return new TokenListProvider().resolve();case 2:res=_context.sent;list=res.filterByChainId(chain.chainID).excludeByTag(\"nft\").getList();knownMints=list.reduce(function(map,item){map.set(item.address,item);return map;},new Map());_context.next=7;return getMultipleAccounts(connection,_toConsumableArray(knownMints.keys()),'single');case 7:accounts=_context.sent;accounts.keys.forEach(function(key,index){var account=accounts.array[index];if(!account){return;}cache.add(new PublicKey(key),account,MintParser);});setTokenMap(knownMints);setTokens(list);case 11:case\"end\":return _context.stop();}}},_callee);}))();},[connection,chain]);setProgramIds(env);// The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n// is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n// This is a hack to prevent the list from every getting empty\nuseEffect(function(){var id=connection.onAccountChange(new Account().publicKey,function(){});return function(){connection.removeAccountChangeListener(id);};},[connection]);useEffect(function(){var id=connection.onSlotChange(function(){return null;});return function(){connection.removeSlotChangeListener(id);};},[connection]);useEffect(function(){var id=sendConnection.onAccountChange(new Account().publicKey,function(){});return function(){sendConnection.removeAccountChangeListener(id);};},[sendConnection]);useEffect(function(){var id=sendConnection.onSlotChange(function(){return null;});return function(){sendConnection.removeSlotChangeListener(id);};},[sendConnection]);return/*#__PURE__*/React.createElement(ConnectionContext.Provider,{value:{endpoint:endpoint,setEndpoint:setEndpoint,slippage:parseFloat(slippage),setSlippage:function setSlippage(val){return _setSlippage(val.toString());},connection:connection,sendConnection:sendConnection,tokens:tokens,tokenMap:tokenMap,env:env}},children);}export function useConnection(){return useContext(ConnectionContext).connection;}export function useSendConnection(){var _useContext;return(_useContext=useContext(ConnectionContext))===null||_useContext===void 0?void 0:_useContext.sendConnection;}export function useConnectionConfig(){var context=useContext(ConnectionContext);return{endpoint:context.endpoint,setEndpoint:context.setEndpoint,env:context.env,tokens:context.tokens,tokenMap:context.tokenMap};}export function useSlippageConfig(){var _useContext2=useContext(ConnectionContext),slippage=_useContext2.slippage,setSlippage=_useContext2.setSlippage;return{slippage:slippage,setSlippage:setSlippage};}var getErrorForTransaction=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection,txid){var tx,errors;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return connection.confirmTransaction(txid,\"max\");case 2:_context2.next=4;return connection.getParsedConfirmedTransaction(txid);case 4:tx=_context2.sent;errors=[];if((tx===null||tx===void 0?void 0:tx.meta)&&tx.meta.logMessages){tx.meta.logMessages.forEach(function(log){var regex=/Error: (.*)/gm;var m;while((m=regex.exec(log))!==null){// This is necessary to avoid infinite loops with zero-width matches\nif(m.index===regex.lastIndex){regex.lastIndex++;}if(m.length>1){errors.push(m[1]);}}});}return _context2.abrupt(\"return\",errors);case 8:case\"end\":return _context2.stop();}}},_callee2);}));return function getErrorForTransaction(_x,_x2){return _ref3.apply(this,arguments);};}();export var sendTransaction=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection,wallet,instructions,signers){var _transaction;var awaitConfirmation,transaction,_transaction2,rawTransaction,options,txid,status,errors,_args3=arguments;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:awaitConfirmation=_args3.length>4&&_args3[4]!==undefined?_args3[4]:true;if(wallet===null||wallet===void 0?void 0:wallet.publicKey){_context3.next=3;break;}throw new Error(\"Wallet is not connected\");case 3:transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});_context3.next=7;return connection.getRecentBlockhash(\"max\");case 7:transaction.recentBlockhash=_context3.sent.blockhash;(_transaction=transaction).setSigners.apply(_transaction,[// fee payied by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));if(signers.length>0){(_transaction2=transaction).partialSign.apply(_transaction2,_toConsumableArray(signers));}_context3.next=12;return wallet.signTransaction(transaction);case 12:transaction=_context3.sent;rawTransaction=transaction.serialize();options={skipPreflight:true,commitment:\"singleGossip\"};_context3.next=17;return connection.sendRawTransaction(rawTransaction,options);case 17:txid=_context3.sent;if(!awaitConfirmation){_context3.next=28;break;}_context3.next=21;return connection.confirmTransaction(txid,options&&options.commitment);case 21:status=_context3.sent.value;if(!(status===null||status===void 0?void 0:status.err)){_context3.next=28;break;}_context3.next=25;return getErrorForTransaction(connection,txid);case 25:errors=_context3.sent;notify({message:\"Transaction failed...\",description:/*#__PURE__*/React.createElement(React.Fragment,null,errors.map(function(err){return/*#__PURE__*/React.createElement(\"div\",null,err);}),/*#__PURE__*/React.createElement(ExplorerLink,{address:txid,type:\"transaction\"})),type:\"error\"});throw new Error(\"Raw transaction \".concat(txid,\" failed (\").concat(JSON.stringify(status),\")\"));case 28:return _context3.abrupt(\"return\",txid);case 29:case\"end\":return _context3.stop();}}},_callee3);}));return function sendTransaction(_x3,_x4,_x5,_x6){return _ref4.apply(this,arguments);};}();","map":null,"metadata":{},"sourceType":"module"}